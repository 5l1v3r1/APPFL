import Prelude
import Parser

--import Control.Monad.State.Lazy

newtype State s a = State (s -> (a, s))

state :: (s -> (a, s)) -> State s a
state x = State x

runState :: State s a -> s -> (a, s)
runState (State f) x = f x

instance Monad (State s) where
    return x = state (\st -> (x, st))
    act >>= k = state $ \st -> 
                          let (x, st') = runState act st
                          in runState (k x) st'

get = State $ \s -> (s,s)

put newState = State $ \s -> ((), newState)  

type NameSupply = [String]
nameSupply = [ show i | i <- [1..]]

-- only have to get into the monad one time, here
suffixname v = State $ \(x:xs) -> (v++x, xs)

nameDef :: (String, Obj) -> State NameSupply (String, Obj)
nameDef (v, o) =
    do
      v' <- suffixname v
      o' <- nameObj o
      return (v, o')

nameExpr :: Expr -> State NameSupply Expr
nameExpr (ELet fvs defs e) =
    do
      defs' <- mapM nameDef defs
      e' <- nameExpr e
      return (ELet fvs defs' e')

nameExpr (ECase fvs e alts) =
    do
      e' <- nameExpr e
      alts' <- mapM nameAlt alts
      return (ECase fvs e' alts')

-- EAtom, EFCall, EPrimop
nameExpr e = return e


nameAlt (ACon fvs c vs e) = 
    do
      e' <- nameExpr e
      return (ACon fvs c vs e')

nameAlt (ADef fvs v e) = 
    do
      e' <- nameExpr e
      return (ADef fvs v e')


nameObj (FUN fvs vs e) =
    do
      e' <- nameExpr e
      return (FUN fvs vs e')

nameObj (THUNK fvs e) =
    do
      e' <- nameExpr e
      return (THUNK fvs e')

--PAP, CON, BLACKHOLE
nameObj o = return o
