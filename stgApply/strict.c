#include "stg.h"
#include "cmm.h"
#include "stgutils.h"
#include "stgApply.h"
#include <stdlib.h>
#include <stdio.h>

DEFUN0(stgApplyN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 1;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0800000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0400000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 1);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args not possible

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0400000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 1);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 1;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x0800000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0800000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0400000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 1);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args not possible

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0400000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 1);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 2;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0C00000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000000UL );
      // push needed args
      newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // restore excess args left shifted into argv
      callContRestore( &argv[1] );
      argv[0] = stgCurVal;
      // push excess args
      newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply
      STGJUMP0(stgApplyN);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0C00000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0800000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000000UL );
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // stash the FUN-oid
      argv[0] = stgCurVal;
      // restore excess args left shifted into argv[1]
      callContRestore( &argv[1] );
      // push FUN-oid and excess args
      newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply 
      STGJUMP0(stgApplyN);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0800000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0800000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 2;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x0C00000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0C00000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000000UL );
      // push needed args
      newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // restore excess args left shifted into argv
      callContRestore( &argv[1] );
      argv[0] = stgCurVal;
      // push excess args
      newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply
      STGJUMP0(stgApplyN);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0C00000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0800000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000000UL );
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // stash the FUN-oid
      argv[0] = stgCurVal;
      // restore excess args left shifted into argv[1]
      callContRestore( &argv[1] );
      // push FUN-oid and excess args
      newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply 
      STGJUMP0(stgApplyN);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0800000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0800000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 2;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x0C00000000000005UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0C00000000000005UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000001UL );
      // push needed args
      newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
      newframe->layout = (Bitmap64)0x0800000000000001UL;
      memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // restore excess args left shifted into argv
      callContRestore( &argv[1] );
      argv[0] = stgCurVal;
      // push excess args
      newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply
      STGJUMP0(stgApplyP);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0C00000000000005UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0800000000000002UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000001UL );
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // stash the FUN-oid
      argv[0] = stgCurVal;
      // restore excess args left shifted into argv[1]
      callContRestore( &argv[1] );
      // push FUN-oid and excess args
      newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply 
      STGJUMP0(stgApplyP);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0800000000000002UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0800000000000002UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 2;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x0C00000000000007UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x0C00000000000007UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x0C00000000000007UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000001UL );
      // push needed args
      newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // restore excess args left shifted into argv
      callContRestore( &argv[1] );
      argv[0] = stgCurVal;
      // push excess args
      newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply
      STGJUMP0(stgApplyP);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x0C00000000000007UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0800000000000003UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess args
      callContSave( &argv[2], (Bitmap64)0x0400000000000001UL );
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0400000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // call-with-return the FUN
      STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
      // stash the FUN-oid
      argv[0] = stgCurVal;
      // restore excess args left shifted into argv[1]
      callContRestore( &argv[1] );
      // push FUN-oid and excess args
      newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
      newframe->layout = (Bitmap64)0x0800000000000003UL;
      memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
      // try again - tail call stgApply 
      STGJUMP0(stgApplyP);
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0800000000000003UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0800000000000003UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 2);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1000000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1000000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1000000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1000000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1000000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1000000000000005UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1000000000000005UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1000000000000005UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000002UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000002UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000002UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1000000000000007UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1000000000000007UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1000000000000007UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1000000000000007UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000003UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000003UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000003UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1000000000000009UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1000000000000009UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1000000000000009UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000004UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000004UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000004UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x100000000000000BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x100000000000000BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x100000000000000BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x100000000000000BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000005UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000005UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000005UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x100000000000000DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x100000000000000DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x100000000000000DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x100000000000000DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000006UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000006UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000006UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 3;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x100000000000000FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x100000000000000FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x100000000000000FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x100000000000000FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x100000000000000FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x0C00000000000007UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x0C00000000000007UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x0C00000000000007UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 3);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000005UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000005UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000005UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000002UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000002UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000002UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000007UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000007UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000007UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000007UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000003UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000003UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000003UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000009UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000009UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000009UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000004UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000004UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000004UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000000BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000000BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000000BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000000BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000005UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000005UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000005UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000000DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000000DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000000DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000000DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000006UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000006UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000006UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000000FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000000FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000000FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000000FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000000FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000007UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000007UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000007UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000011UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000011UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000011UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000008UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000008UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000008UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000013UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000013UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000013UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000013UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1000000000000009UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1000000000000009UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1000000000000009UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000015UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000015UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000015UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000015UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000017UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000017UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000017UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000017UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000017UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1400000000000019UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1400000000000019UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1400000000000019UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1400000000000019UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000001BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000001BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000001BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000001DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000001DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000001DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 4;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x140000000000001FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x140000000000001FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x140000000000001FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x140000000000001FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x100000000000000FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x100000000000000FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x100000000000000FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 4);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000005UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000005UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000005UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000002UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000002UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000002UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000007UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000007UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000007UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000007UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000003UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000003UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000003UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000009UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000009UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000009UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000004UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000004UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000004UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000000BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000000BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000000BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000000BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000005UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000005UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000005UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000000DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000000DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000000DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000000DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000006UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000006UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000006UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000000FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000000FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000000FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000000FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000000FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000007UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000007UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000007UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000011UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000011UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000011UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000008UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000008UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000008UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000013UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000013UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000013UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000013UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000009UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000009UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000009UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000015UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000015UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000015UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000015UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000017UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000017UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000017UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000017UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000017UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000019UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000019UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000019UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000019UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000001BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000001BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000001BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000001DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000001DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000001DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000001FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000001FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000001FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000001FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000000FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000000FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000000FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000021UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000021UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000021UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000010UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000010UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000010UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000023UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000023UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000023UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000023UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000011UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000011UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000011UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000025UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000025UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000025UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000025UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000012UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000012UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000012UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000027UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000027UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000027UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000027UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000027UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000013UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000013UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000013UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000029UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000029UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000029UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000029UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000014UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000014UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000014UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000002BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000002BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000002BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000015UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000015UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000015UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000002DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000002DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000002DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000016UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000016UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000016UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000002FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000002FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000002FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000002FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000017UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000017UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000017UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000031UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000031UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000031UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000031UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000018UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000018UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000018UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000033UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000033UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000033UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000033UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000033UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1400000000000019UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1400000000000019UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1400000000000019UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000035UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000035UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000035UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000035UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000035UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000037UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000037UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000037UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000037UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000037UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000037UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1800000000000039UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000039UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1800000000000039UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1800000000000039UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1800000000000039UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000003BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000003BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000003BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000003DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000003DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000003DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 5;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x180000000000003FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x180000000000003FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x140000000000001FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x140000000000001FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x140000000000001FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 5);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  
  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000001UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000001UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000000UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000000UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000000UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000003UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000003UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000003UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000001UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000001UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000001UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000005UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000005UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000005UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000002UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000002UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000002UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000007UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000007UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000007UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000007UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000003UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000003UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000003UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000009UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000009UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000009UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000004UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000004UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000004UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000000BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000000BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000005UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000005UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000005UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000000DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000000DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000006UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000006UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000006UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000000FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000000FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000000FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000007UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000007UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000007UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000011UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000011UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000011UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000008UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000008UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000008UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000013UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000013UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000013UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000013UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000009UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000009UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000009UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000015UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000015UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000015UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000015UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000017UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000017UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000017UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000017UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000017UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000019UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000019UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000019UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000019UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000001BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000001BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000001DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000001DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPNN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000001FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000001FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPNN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000001FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000000FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPNN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000000FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000000FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000021UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000021UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000021UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000010UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000010UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000010UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000010UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000023UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000023UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000023UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000023UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000011UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000011UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000011UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000011UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000025UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000025UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000025UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000025UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000012UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000012UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000012UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000012UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000027UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000027UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000027UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000027UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000027UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000013UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000013UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000013UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000013UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000029UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000029UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000029UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000029UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000014UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000014UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000014UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000014UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000002BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000002BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000015UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000015UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000015UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000015UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000002DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000002DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000016UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000016UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000016UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000016UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000002FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000002FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000002FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000017UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000017UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000017UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000017UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000031UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000031UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000031UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000031UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000018UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000018UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000018UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000018UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000033UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000033UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000033UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000033UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000033UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000019UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000019UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000019UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000019UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000035UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000035UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000035UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000035UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000035UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000037UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000037UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000037UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000037UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000037UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000037UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000039UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000039UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000039UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000039UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000039UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000003BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000003BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000003DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000003DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPPN) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPN %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000003FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPPN THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000003FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000001FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000000UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyN);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPN);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPN);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPN);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPPN);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000001FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000001FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPN!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000041UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000041UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000010UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000041UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000020UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000010UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000020UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000020UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000043UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000043UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000043UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000010UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000043UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000021UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000010UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000021UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000021UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000045UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000045UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000045UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000011UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000045UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000022UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000011UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000022UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000022UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000047UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000047UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000047UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000047UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000011UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000047UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000023UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000008UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000011UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000023UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000023UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000049UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000049UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000049UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000012UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000049UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000024UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000012UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000024UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000024UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004BUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000004BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000012UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000004BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000025UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000012UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000025UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000025UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004DUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000004DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000013UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000004DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000026UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000013UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000026UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000026UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000004FUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000004FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000013UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000004FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000027UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000004UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x1000000000000009UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000013UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000027UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000027UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000051UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000051UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000051UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000014UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000051UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000028UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000014UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000028UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000028UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000053UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000053UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000053UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000053UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000014UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000053UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000029UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000014UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000029UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000029UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000055UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000055UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000055UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000055UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000015UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000055UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000015UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000057UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000057UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000057UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000057UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000057UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000015UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000057UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000015UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000059UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000059UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000059UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000059UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000016UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000059UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000016UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005BUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000005BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000016UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000005BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000016UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005DUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000005DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000017UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000005DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000017UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPNP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000005FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPNP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000017UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000005FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000002FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000002UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000005UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000017UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPNP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000002FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000002FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000061UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000061UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000061UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000021UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000018UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000061UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000030UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000010UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000018UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000030UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000030UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000063UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000063UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000063UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000063UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000023UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000018UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000063UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000031UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000011UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000018UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000031UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000031UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000065UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000065UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000065UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000065UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000025UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000019UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000065UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000032UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000012UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000019UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000032UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000032UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000067UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000067UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000067UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000067UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000067UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000027UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000019UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000067UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000033UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000013UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x1400000000000019UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000033UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000033UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000069UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000069UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000069UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000069UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000029UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000069UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000034UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000014UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000034UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000034UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006BUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000006BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001AUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000006BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000035UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000015UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001AUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000035UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000035UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006DUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000006DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000006DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000036UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000016UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000036UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000036UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPNPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000006FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPNPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000002FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001BUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000006FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000037UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000017UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000006UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001BUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPNPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000037UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000037UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000071UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000071UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000071UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000071UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000031UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000011UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000071UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000038UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000018UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000008UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000038UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000038UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000073UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000073UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000073UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000073UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000073UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000033UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000013UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001CUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000073UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x1800000000000039UL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1400000000000019UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x1000000000000009UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001CUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x1800000000000039UL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x1800000000000039UL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000075UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000075UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000075UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000075UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000075UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000035UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000015UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000075UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003AUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000AUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003AUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003AUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPNPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000077UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPNPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000037UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000017UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001DUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000077UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003BUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000BUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001DUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPNPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003BUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003BUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNNPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C00000000000079UL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000079UL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000079UL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C00000000000079UL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C00000000000079UL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNNPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1800000000000039UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1400000000000019UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x1000000000000009UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C00000000000079UL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003CUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000CUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000004UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003CUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003CUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPNPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000007BUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPNPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000BUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001EUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyNPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000007BUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003DUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000DUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000005UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001EUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyNPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003DUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003DUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyNPPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000007DUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyNPPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000DUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000005UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000001UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000007DUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003EUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000EUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000006UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000002UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000000UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003EUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003EUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN0(stgApplyPPPPPP) {
  Cont *newframe;  // pointer to STACKCONT to be constructed for call/jump
  const int argc = 6;
  PtrOrLiteral argv[argc+1]; // argv[0] is the FUN/PAP/THUNK/BLACKHOLE
  popFrameArgs(argc+1, argv);
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPP %s\n", getInfoPtr(argv[0].op)->name);
  #endif
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[1]);
  callContRestore( &argv[0] );
  argv[1] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[2]);
  callContRestore( &argv[0] );
  argv[2] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[3]);
  callContRestore( &argv[0] );
  argv[3] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[4]);
  callContRestore( &argv[0] );
  argv[4] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[5]);
  callContRestore( &argv[0] );
  argv[5] = stgCurVal;  // stgCurVal possibly less indirect
  callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
  STGEVAL(argv[6]);
  callContRestore( &argv[0] );
  argv[6] = stgCurVal;  // stgCurVal possibly less indirect

  argv[0].op = derefPoL(argv[0]);
  if (getObjType(argv[0].op) == THUNK) {
    callContSave( &argv[0], (Bitmap64)0x1C0000000000007FUL );
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "stgApplyPPPPPP THUNK\n");
    #endif
    STGEVAL(argv[0]);
    callContRestore( &argv[0] );
    // this works because stgCurVal is a GC root
    argv[0].op = derefPoL(stgCurVal);
  } // if THUNK

  switch (getObjType(argv[0].op)) {
  case FUN: {
    int arity = getInfoPtr(argv[0].op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001FUL );
        // push needed args
        newframe = stgAllocStackCont( &it_stgStackCont, arity+1 );
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(newframe->payload, argv, (arity+1) * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // restore excess args left shifted into argv
        callContRestore( &argv[1] );
        argv[0] = stgCurVal;
        // push excess args
        newframe = stgAllocStackCont( &it_stgStackCont, excess+1 );
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(newframe->payload, argv, (excess+1) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply
        STGJUMP0(stgApplyPPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN just right\n");
      #endif
      newframe = stgAllocStackCont( &it_stgStackCont, argc+1 );
      newframe->layout = (Bitmap64)0x1C0000000000007FUL;
      memcpy(newframe->payload, argv, (argc+1) * sizeof(PtrOrLiteral));
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                    getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
      // stgNewHeapPAPmask puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), (Bitmap64)0x180000000000003FUL);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy args to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(argv[0].op)->layoutInfo.boxedCount + 
                  getInfoPtr(argv[0].op)->layoutInfo.unboxedCount;
    Bitmap64 bitmap = argv[0].op->payload[fvCount].b;
    Bitmap64 bitmap2;
    int argCount = BMSIZE(bitmap);
    int arity = getInfoPtr(argv[0].op)->funFields.arity - argCount;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "PAP/FUN %s arity %d\n", getInfoPtr(argv[0].op)->name, getInfoPtr(argv[0].op)->funFields.arity);
    #endif
    int excess = argc - arity;    // may be negative

    // too many args?
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[6], (Bitmap64)0x0400000000000001UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x140000000000001FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0800000000000003UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyP);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[5], (Bitmap64)0x0800000000000003UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x100000000000000FUL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x0C00000000000007UL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPP);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[4], (Bitmap64)0x0C00000000000007UL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0C00000000000007UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x100000000000000FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPP);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[3], (Bitmap64)0x100000000000000FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0800000000000003UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x140000000000001FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPP);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess args
        callContSave( &argv[2], (Bitmap64)0x140000000000001FUL );
        bitmap.bitmap.mask <<= 1;
        bitmap.bitmap.mask |= 0x1;
        bitmap.bitmap.size += 1;
        bitmap2 = (Bitmap64)0x0400000000000001UL;
        bitmap2.bitmap.mask <<= (argCount + 1);
        bitmap.bits += bitmap2.bits;
        newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
        newframe->layout = bitmap;
        newframe->payload[0] = argv[0]; // self
        memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
        memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
        // call-with-return the FUN
        STGCALL0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);
        // stash the FUN-oid
        argv[0] = stgCurVal;
        // restore excess args left shifted into argv[1]
        callContRestore( &argv[1] );
        // push FUN-oid and excess args
        newframe = stgAllocStackCont(&it_stgStackCont, 1 + excess);
        newframe->layout = (Bitmap64)0x180000000000003FUL;
        memcpy(&newframe->payload[0], &argv[0], (1 + excess) * sizeof(PtrOrLiteral));
        // try again - tail call stgApply 
        STGJUMP0(stgApplyPPPPP);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right?
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP just right\n");
      #endif
      // push new args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "PAP just right:  %d args in PAP, %d new args\n", argCount, arity);
      #endif
      bitmap.bitmap.mask <<= 1;
      bitmap.bitmap.mask |= 0x1;
      bitmap.bitmap.size += 1;
      bitmap2 = (Bitmap64)0x180000000000003FUL;
      bitmap2.bitmap.mask <<= (argCount + 1);
      bitmap.bits += bitmap2.bits;
      newframe = stgAllocStackCont( &it_stgStackCont, argCount+arity+1 );
      newframe->layout = bitmap;
      newframe->payload[0] = argv[0]; // self
      memcpy(&newframe->payload[1], &argv[0].op->payload[fvCount+1], argCount * sizeof(PtrOrLiteral)); // old args
      memcpy(&newframe->payload[1 + argCount], &argv[1], arity * sizeof(PtrOrLiteral));
      // tail call the FUN
      STGJUMP0(getInfoPtr(argv[0].op)->funFields.trueEntryCode);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too few args\n");
      #endif
      // bitmap for new args
      Bitmap64 bmold = argv[0].op->payload[fvCount].b;
      Bitmap64 bmnew = (Bitmap64)0x180000000000003FUL;
      // shift mask by known only at runtime #existing PAP args
      bmnew.bitmap.mask <<= argCount;
      bmnew.bits += bmold.bits;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAPmask(getInfoPtr(argv[0].op), bmnew);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &argv[0].op->payload[0], fvCount);
      // copy old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old args into new PAP\n", argCount);
      #endif
      copyargs(&pap->payload[fvCount+1], &argv[0].op->payload[fvCount+1], argCount);
      // copy new args to just after fvs, layout info, and old args
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new args into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+argCount], &argv[1], 6);
      stgCurVal = HOTOPL(pap);
      STGRETURN0();
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPP!\n");
    showStgHeap();
    assert(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

