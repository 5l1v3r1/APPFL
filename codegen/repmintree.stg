data T a = L a | B a (T a) (T a);

leaf = FUN(a -> let {r = CON(L a)} in r);
branch = FUN(v l r -> let {t = CON(B v l r)} in t);

val = FUN(tree -> 
    case tree of {
      L v -> v;
      B v l r -> v});


repMin = FUN(tree -> let {v = THUNK(val tree);
       	 	     	  pr = THUNK(_repMin tree v min);
			  min = THUNK(snd pr);}
	             in fst pr);


_repMin = FUN(tr ac min -> 
	case tr of {
	  L v -> 
	    let { m = THUNK(minInt ac v);
	          lf = THUNK(leaf min);}
	    in tupl2 lf m;
	  B v l r ->
	    let { pL = THUNK(_repMin l ac m);
	    	  pR = THUNK(_repMin r ac m);
		  mL = THUNK(snd pL);
		  mR = THUNK(snd pR);
		  tL = THUNK(fst pL);
		  tR = THUNK(fst pR);
		  m1 = THUNK(minInt mL mR);
		  m  = THUNK(minInt m1 v);
		  br = THUNK(branch min tL tR);}
  	    in tupl2 br m;});


forceTree = FUN(tr -> 
	  case tr of {
	    L v -> 
	      case v of {
	      	a -> leaf a};
	    B v l r -> 
	      case forceTree l of {
	      	ll -> 
		  case forceTree r of {
		    rr -> 
		      case v of {
		      	a -> branch a ll rr}}}});

makeTree = FUN(n -> 
	 case eqInt n zero of {
	   True -> leaf n;
	   False -> let { m = THUNK(subInt n one); 
	   	    	  l = THUNK(makeTree m);
			  r = THUNK(makeTree m);}
	            in branch n l r});

myTree = THUNK(makeTree three);


minTree = THUNK(repMin myTree);

main = THUNK(id id one);
id = FUN(x -> x);