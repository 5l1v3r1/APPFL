data Unit = Unit;
data Bool = B Bool#;
data Int = I Int#;
data List a = Nil | Cons a (List a);

error = ERROR;
unit = CON(Unit);
true = CON(B true#);
false = CON(B false#);
nil = CON(Nil);
zero = CON(I 0);
one = CON(I 1);
two = CON(I 2);
three = CON(I 3);
four = CON(I 4);
five = CON(I 5);
six = CON(I 6);
seven = CON(I 7);
eight = CON(I 8);
nine = CON(I 9);
ten = CON(I 10);

multInt = FUN(x y ->
   case x of { 
      I i# -> case y of { 
               I j# -> case imul# i# j# of { 
                         x# -> let { result = CON (I x#) } in result }}});


plusInt = FUN(x y ->
   case x of { 
      I i# -> case y of { 
               I j# -> case iplus# i# j# of { 
                         x# -> let { result = CON (I x#) } in result }}});

subInt = FUN(x y ->
           case x of
              { I i# ->
                  case y of
                     { I j# -> case isub# i# j# of
                                 { x# -> let { result = CON (I x#) } in result }}});

append = FUN(l1 l2 ->
            case l1 of
               { Nil -> l2;
                 Cons hd tl -> let { rec = THUNK(append tl l2);
                                     result = CON(Cons hd rec) }
                               in result });

const = FUN(x y -> x);
apply = FUN(f x -> f x);

map = FUN(f list ->
   case list of {
      Nil -> nil;
      Cons h t -> let { x = THUNK(f h); rec = THUNK(map f t); res = CON(Cons x rec) } in res
   });

head = FUN(xs -> case xs of { Cons hd tl -> hd });
tail = FUN(xs -> case xs of { Cons hd tl -> tl });

foldl = FUN(f acc list ->
   case list of {
      Nil -> acc;
      Cons h t -> let { newAcc = THUNK(f acc h) } in foldl f newAcc t 
   });

-- lazy sum with a well-known space leak
sum = FUN(list -> foldl plusInt zero list);

