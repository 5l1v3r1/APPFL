data Unit = Unit;
data Int = I Int#;
data List a = Nil | Cons a (List a);
data Bool = False | True;


error = ERROR;
unit = CON(Unit);
nil = CON(Nil);
zero = CON(I 0);
one = CON(I 1);
two = CON(I 2);
three = CON(I 3);
four = CON(I 4);
five = CON(I 5);
six = CON(I 6);
seven = CON(I 7);
eight = CON(I 8);
nine = CON(I 9);
ten = CON(I 10);

false = CON(False);
true = CON(True);

eqInt = FUN(x y ->
           case x of
              { I i# ->
                  case y of
                     { I j# -> case ieq# i# j# of
                                 { 0 -> false;
                                   x -> true }}});

multInt = FUN(x y ->
   case x of { 
      I i# -> case y of { 
               I j# -> case imul# i# j# of { 
                         x# -> let { result = CON (I x#) } in result }}});


plusInt = FUN(x y ->
   case x of { 
      I i# -> case y of { 
               I j# -> case iplus# i# j# of { 
                         x# -> let { result = CON (I x#) } in result }}});

subInt = FUN(x y ->
           case x of
              { I i# ->
                  case y of
                     { I j# -> case isub# i# j# of
                                 { x# -> let { result = CON (I x#) } in result }}});

append = FUN(l1 l2 ->
            case l1 of
               { Nil -> l2;
                 Cons hd tl -> let { rec = THUNK(append tl l2);
                                     result = CON(Cons hd rec) }
                               in result });

const = FUN(x y -> x);
apply = FUN(f x -> f x);

map = FUN(f list ->
   case list of {
      Nil -> nil;
      Cons h t -> let { x = THUNK(f h); rec = THUNK(map f t); res = CON(Cons x rec) } in res
   });

head = FUN(xs -> case xs of { Cons hd tl -> hd });
tail = FUN(xs -> case xs of { Cons hd tl -> tl });

foldl = FUN(f acc list ->
   case list of {
      Nil -> acc;
      Cons h t -> let { newAcc = THUNK(f acc h) } in foldl f newAcc t 
   });

-- lazy sum with a well-known space leak
sum = FUN(list -> foldl plusInt zero list);

zipWith = FUN(f list1 list2 ->
   case list1 of {
      Nil -> nil;
      Cons h1 t1 -> 
         case list2 of {
            Nil -> nil;
            Cons h2 t2 ->
               let { newHead = THUNK(f h1 h2); 
                     newTail = THUNK(zipWith f t1 t2);
                     result = CON(Cons newHead newTail)
               } in result
         }
   });

seq = FUN(x y -> case x of { z -> y });

forcelist = FUN(list ->
   case list of {
      Nil -> unit;
      Cons h t -> let { rec = THUNK(forcelist t) } in seq h rec });

take = FUN(n xs ->
   case eqInt n zero of
      { True -> nil;
        False -> case xs of
                 { Nil -> nil;
                   Cons hd tl -> let { m = THUNK(subInt n one);
                                       rec = THUNK(take m tl);
                                       result = CON(Cons hd rec) } in result }});

-- make infinite homogenous lists!
repeat = FUN(x -> let { next = THUNK(repeat x) } in cons x next);

-- make arbitrarily long homogenous lists!
replicate = FUN(n x -> let {list = THUNK(repeat x)} in take n list);

-- seq a list
strictList = FUN(xs ->
      	     	    case xs of {
       	    	    	 Nil -> nil;
	    	  	 Cons h t -> case strictList t of {
	    	     	           	  x -> cons h x }});

-- construct a Cons cell
cons = FUN(h t -> let {r = CON(Cons h t)} in r);

-- remove n elements from the head of a list
drop = FUN(n xs -> case eqInt n zero of {
       	     	   	      True -> xs;
			      False -> case xs of {
       	     	   	      	       	    Nil -> nil;
					    Cons h t -> let {m = THUNK(subInt n one)}
					    	     	in drop m t }});

-- is a list empty?
null = FUN(xs -> case xs of {
       	      	      Nil -> true;
		      x   -> false});


-- take all but the last element of a list
-- init :: List a -> List a
init = FUN(xs -> case xs of {
       	      	      Nil -> nil;
		      Cons h t -> case null t of {
		      	       	       True -> nil;
				       False ->	let { l = THUNK(init t) } in cons h l }});

-- keep all the elements in a list that satisfy a predicate
-- filter :: (a -> Bool) -> List a -> List a
filter = FUN(p xs -> case xs of {
       	       	     Nil -> nil;
		     Cons h t -> let {tail = THUNK(filter p t)} in 
		     	      	     case p h of {
		     	  	     True -> cons h tail;
				     False -> tail }});


-- check if all elements of a list satisfy a predicate
-- all :: (a -> Bool) -> List a -> Bool
all = FUN(p xs -> case xs of {
      	       	  Nil -> true;
		  Cons h t -> case p h of {
		       	      False -> false;
			      True -> all p t}});

-- check if any elements of a list satisfy a predicate
-- any :: (a -> Bool) -> List a -> Bool
any = FUN(p xs -> case xs of {
      	       	  Nil -> false;
		  Cons h t -> case p h of {
		       	      True -> true;
			      False -> any p t}});


-- odd# :: Int# -> Bool
odd# = FUN(i# -> case imod# i# 2 of {
       	     	 0 -> false;
		 x -> true});


-- even# :: Int# -> Bool
even# = FUN(i# -> case odd# i# of { x -> not x });


-- odd :: Int -> Bool
odd = FUN(i -> case i of { I i# -> odd# i# });


-- even :: Int -> Bool
even = THUNK(compose not odd);


-- not :: Bool -> Bool
not = FUN(b -> case b of {
      	       False -> true;
	       True  -> false});


-- compose :: (b -> c) -> (a -> b) -> a -> c
compose = FUN(f g x -> case g x of { r -> f r});