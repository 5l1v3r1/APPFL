## Prelude.stg

error = ERROR;
unit = CON(Unit);
true = CON(True);
false = CON(False);
nil = CON(Nil);
zero = CON(I 0);
one = CON(I 1);
two = CON(I 2);
three = CON(I 3);
four = CON(I 4);
five = CON(I 5);
six = CON(I 6);
seven = CON(I 7);
eight = CON(I 8);
nine = CON(I 9);
ten = CON(I 10);

multInt = FUN(x y ->
   case x of { 
      I i -> case y of { 
               I j -> case mult# i j of { 
                         x -> let { result = CON (I x) } in result }}});

plusInt = FUN(x y ->
   case x of { 
      I i -> case y of { 
               I j -> case plus# i j of { 
                         x -> let { result = CON (I x) } in result }}});

subInt = FUN(x y ->
           case x of
              { I i ->
                  case y of
                     { I j -> case sub# i j of
                                 { x -> let { result = CON (I x) } in result }}});

eqInt = FUN(x y ->
           case x of
              { I i ->
                  case y of
                     { I j -> case eq# i j of
                                 { x -> intToBool# x }}});

append = FUN(l1 l2 ->
            case l1 of
               { Nil -> l2;
                 Cons hd tl -> let { rec = THUNK(append tl l2);
                                     result = CON(Cons hd rec) }
                               in result });

constf = FUN(x y -> x);
apply = FUN(f x -> f x);

map = FUN(f list ->
   case list of {
      Nil -> nil;
      Cons h t -> let { x = THUNK(f h); rec = THUNK(map f t); res = CON(Cons x rec) } in res
   });

take = FUN(n xs ->
   case eqInt n zero of
      { True -> nil;
        False -> case xs of
                 { Nil -> nil;
                   Cons hd tl -> let { m = THUNK(subInt n one);
                                       rec = THUNK(take m tl);
                                       result = CON(Cons hd rec) } in result }});

head = FUN(xs -> case xs of { Cons hd tl -> hd });
tail = FUN(xs -> case xs of { Cons hd tl -> tl });

foldl = FUN(f acc list ->
   case list of {
      Nil -> acc;
      Cons h t -> let { newAcc = THUNK(f acc h) } in foldl f newAcc t 
   });

# lazy sum with a well-known space leak
sum = FUN(list -> foldl plusInt zero list);

zipWith = FUN(f list1 list2 ->
   case list1 of {
      Nil -> nil;
      Cons h1 t1 -> 
         case list2 of {
            Nil -> nil;
            Cons h2 t2 ->
               let { newHead = THUNK(f h1 h2); 
                     newTail = THUNK(zipWith f t1 t2);
                     result = CON(Cons newHead newTail)
               } in result
         }
   });

seq = FUN(x y -> case x of { z -> y });

forcelist = FUN(list ->
   case list of {
      Nil -> unit;
      Cons h t -> let { rec = THUNK(forcelist t) } in seq h rec });

#### end Prelude.stg

## append.stg
list1 = CON(Cons one nil);
list2 = CON(Cons one list1);
list3 = CON(Cons zero list2);
list4 = THUNK(append list3 list3);
list5 = THUNK(append list4 list4);
mainappend = THUNK(let { f = THUNK(forcelist list5)} in seq f list5);

## apply.stg
twentytwo = CON(I 22);
mainapply = THUNK(apply constf true twentytwo);

## docs.stg
nil = CON(Nil);
zero = CON(I 0);
one = CON(I 1);
two = CON(I 2);
three = CON(I 3);
 
plusInt = FUN(x y ->
   case x of {
      I i -> case y of {
               I j -> case plus# i j of {
                         x -> let { result = CON (I x) } in result }}});
 
# lazy sum with a well-known space leak
sum = FUN(list -> foldl plusInt zero list);
 
list1 = CON(Cons one nil);
list2 = CON(Cons two list1);
list3 = CON(Cons three list2);
 
maindocs = THUNK(sum list3);

## error.stg
mainerror = ERROR;

## fac.stg
fac = FUN (x -> 
         case eqInt x zero of {
            True -> one;
            False -> let { s = THUNK(subInt x one);
                           rec = THUNK(fac s) }
                     in multInt x rec
         });

mainfac = THUNK (fac seven);

## fibs.stg
# fibs = 1 : 1 : zipWith (+) fibs (tail fibs)

fibs = THUNK(let { tailFibs = THUNK(tail fibs);
                   zippedList = THUNK(zipWith plusInt fibs tailFibs);
                   tailList = CON(Cons one zippedList);
                   list = CON(Cons one tailList)
             } in list);

mainfibs = THUNK( let { result = THUNK(take five fibs);
                    f = THUNK(forcelist result)
                  } in seq f result);
## loop.stg
# this should crash with a blackhole.
mainloop = THUNK(main);

# in Haskell: main = head (map constf [7,2,1]) 10 

list1 = CON(Cons one nil);
list2 = CON(Cons two list1);
list3 = CON(Cons seven list2);
main1 = THUNK(let { mc = THUNK(map constf list3);
                   constSeven = THUNK(head mc)
                 } in constSeven ten);
pzero = CON(Z);
pone = CON(S pzero);
list1 = CON(Cons pone nil);
list2 = CON(Cons pone list1);
list3 = CON(Cons pone list2);
list4 = CON(Cons pone list3); 
consttrue = PAP(constf true);
main2 = THUNK( let { result = THUNK(map constf list4);
                     f = THUNK(forcelist result) 
                   } in seq f result );

nil = CON(Nil);
zero = CON(J 0);
one = CON(J 1);
two = CON(J 2);
three = CON(J 3);
 
plusInt = FUN(x y ->
   case x of {
      J i -> case y of {
               J j -> case plus# i j of {
                         x -> let { result = CON (J x) } in result }}});
 
list1 = CON(Cons one nil);
list2 = CON(Cons two list1);
list3 = CON(Cons three list2);
 
main3 = THUNK(sum list3);
foo = CON(Foo);
end = CON(End);

main4 = THUNK(
   case foo of { Bar -> end; x -> error }
);
ones = CON(Cons one ones);

main5 = THUNK(ones);

# haskell: main = let x = 1 + 2 in seq x (foo x)
main6 = THUNK(let {x = THUNK(plusInt one two);
                   res = THUNK(foo x)} in seq x res);

# compare with
# haskell: main = foo (1 + 2)
# main = THUNK(let {x = THUNK(plusInt one two) } in foo x);
                  

foo = FUN(x -> three);
list1 = CON(Cons one nil);
list2 = CON(Cons error list1);
list3 = CON(Cons three list2);
main7 = THUNK(sum list3);

ones = CON(Cons one ones);

main7 = THUNK(let { result = THUNK(take three ones);
                   f = THUNK(forcelist result)} in seq f result );

leaf = CON(Leaf);    # just out of the blue

branch = FUN(l r -> let { result = CON(Branch l r) } in result);

main8 = THUNK(branch one two);
 