#include "stgc.h"

void registerSHOs();
FnPtr fun_main();

enum tycon_Int {
  con_I };

InfoTab it_one __attribute__((aligned(8))) = 
  { .name                = "one",
    // fvs []
    .entryCode           = &stg_concall,
    .objType             = CON,
    .layoutInfo.payloadSize  = 1,
    // argPerm = [0]
    .layoutInfo.boxedCount   = 0,
    .layoutInfo.unboxedCount = 1,
    .layoutInfo.permString   = "0",
    .conFields.arity     = 1,
    .conFields.tag       = con_I,
    .conFields.conName   = "I",
  };

InfoTab it_main __attribute__((aligned(8))) = 
  { .name                = "main",
    // fvs []
    .entryCode           = &fun_main,
    .objType             = THUNK,
    .layoutInfo.payloadSize = 1,
    .layoutInfo.boxedCount   = 0,
    .layoutInfo.unboxedCount = 0,
  };


extern Obj sho_one;
extern Obj sho_main;

Obj sho_one =
{
  .infoPtr   = (uintptr_t)&it_one,
  .objType   = CON,
  .ident     = "one",
  .payload = {
    {.argType = INT, .i = 1},
},
};

Obj sho_main =
{
  .infoPtr   = (uintptr_t)&it_main,
  .objType   = THUNK,
  .ident     = "main",
  .payload = {0}
};

void registerSHOs() {
  stgStatObj[stgStatObjCount++] = &sho_one;
  stgStatObj[stgStatObjCount++] = &sho_main;
}


// Int[B] 
DEFUN1(fun_main, self) {
  fprintf(stderr, "main here\n");
  stgThunk(self);
  stgCurVal = HOTOPL(&sho_one); // one
  // boxed EAtom, stgCurVal updates itself 
  STGJUMP();
  fprintf(stderr, "main returning\n");
  STGRETURN0();
  ENDFUN;
}

DEFUN0(start)  registerSHOs();
  Cont *showResultCont = stgAllocCallCont(&it_stgShowResultCont, 0);
  stgCurVal.argType = HEAPOBJ;
  stgCurVal.op = &sho_main;
  STGJUMP1(getInfoPtr(stgCurVal.op)->entryCode, stgCurVal);
}

int main (int argc, char **argv) {
  parseArgs(argc, argv);
  initStg();
  initCmm();
  initGc();
  CALL0_0(start);
  showStgHeap();
  GC();
  return 0;
}

