#include "stg.h"
#include "cmm.h"
#include "stgutils.h"
#include "stgApply.h"
#include <stdlib.h>
#include <stdio.h>

DEFUN2(stgApplyN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 1);
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN just right\n");
      #endif
      pushargs(1, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 1);
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[4];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[6];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];
  nargv[5] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN just right\n");
      #endif
      pushargs(6, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 6);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN just right\n");
      #endif
      pushargs(6, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 6 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[3];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPNN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[4];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPNN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[4];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPPN, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPN %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPPN:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[5];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[5] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPNP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPNP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[4];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPNPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPNPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNNPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPNPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyNPPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPPP, N, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPP %s\n", f.op->infoPtr->name);
  #endif
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 6;
  PtrOrLiteral pargv[7];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = argv[5];
  pargv[6] = f;
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(6, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
    argv[5] = pargv[5];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", f.op->infoPtr->name, f.op->infoPtr->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(6, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                    f.op->infoPtr->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 6, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->layoutInfo.boxedCount + 
                  f.op->infoPtr->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApplyPPPPPP:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(6, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 6 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+6], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

