#include "stg.h"
#include "cmm.h"
#include "stgutils.h"
#include "stgApply.h"
#include <stdlib.h>
#include <stdio.h>

DEFUN2(stgApplyN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 1);
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 1);
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyN, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[1];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 2);
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(f.op->infoPtr->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      N.i = excess;
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP2(stgApplyP, N, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[1];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[2];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 3);
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[1];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[2];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 4);
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[1];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[2];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[3];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[4];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 5);
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 0;
  // no pointer args to save
  PtrOrLiteral nargv[6];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];
  nargv[5] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(6, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0, 6);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(6, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 0 + pappargc, 6 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[0];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[1];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[2];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[3];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[3];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[4];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPNN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[4];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[4];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPPN, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyN, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPN, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPN, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPN, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPN, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[1];
  pargv[0] = argv[5];
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[5] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1, 5);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 1 + pappargc, 5 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = argv[5];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = argv[5];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = argv[5];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = argv[5];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPNP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[5];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPNP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[4];
  pargv[1] = argv[5];
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2, 4);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 2 + pappargc, 4 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPNPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPNPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3, 3);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 3 + pappargc, 3 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPNPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPNPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNNPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4, 2);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 4 + pappargc, 2 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPNPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyNPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyNPPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5, 1);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 5 + pappargc, 1 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN2(stgApplyPPPPPP, N, f) {
  assert(N.argType == INT);
  const int argc = N.i;
  assert(argc == 6);
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 6;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = argv[5];
  // no non-pointer args to save

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(6, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
    argv[5] = pargv[5];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = f.op->infoPtr->funFields.arity;
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(6, pargv);
      // tail call the fun
      STGJUMP1(f.op->infoPtr->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN too few args\n");
      #endif
      int fvCount = f.op->infoPtr->fvCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 6, 0);
      pap->argCount = argc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = f.op->infoPtr->fvCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    assert(argCount == f.op->argCount && "stgApply:  PAP error 1");
    int arity = f.op->infoPtr->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyP, N, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPP, N, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPP, N, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPP, N, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(f.op->infoPtr->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        N.i = excess;
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP2(stgApplyPPPPP, N, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(6, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(f.op->infoPtr->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(f.op->infoPtr, 6 + pappargc, 0 + papnargc);
      pap->argCount = argc + pappargc + papnargc;
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+6], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApply!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApply not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

