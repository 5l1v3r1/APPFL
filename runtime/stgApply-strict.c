#include "stg.h"
#include "cmm.h"
#include "stgutils.h"
#include "stgApply.h"
#include <stdlib.h>
#include <stdio.h>

DEFUN1(stgApplyN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 1;
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN just right\n");
      #endif
      pushargs(1, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 1;
  PtrOrLiteral argv[1];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  // no non-pointer args to save
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args not possible

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 2;
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP1(stgApplyN, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP1(stgApplyN, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 2;
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP1(stgApplyN, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      // no excess pointer params to save
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      // no excess pointer params to restore
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP1(stgApplyN, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 2;
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      // 0 pointers to push
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP1(stgApplyP, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[0]);
      // push needed args
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 pointers to push
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      callContRestore(&pargv[0]);
      // restore argv
      argv[1] = pargv[0];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP1(stgApplyP, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 2;
  PtrOrLiteral argv[2];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  // no non-pointer args to save
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(1, pargv);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply
      STGJUMP1(stgApplyP, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too many args\n");
      #endif
      // excess can only be 1
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP to 1 excess args\n");
      #endif
      // stash excess pointer args
      callContSave(1, &pargv[1]);
      // push needed args
      // 0 non-pointers to push
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // call-with-return the FUN
      STGCALL1(getInfoPtr(f.op)->entryCode, f);
      // restore excess args
      callContRestore(&pargv[1]);
      // restore argv
      argv[1] = pargv[1];
      // grab obj just returned
      f = stgCurVal;
      // new argc
      // push excess args
      pushargs(excess, &argv[1]);
      // try again - tail call stgApply 
      STGJUMP1(stgApplyP, f);
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 3;
  PtrOrLiteral argv[3];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  // no non-pointer args to save
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 4;
  PtrOrLiteral argv[4];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  // no non-pointer args to save
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[4];
  pargv[1] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[4] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 5;
  PtrOrLiteral argv[5];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = f;
  // no non-pointer args to save
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 0;
  PtrOrLiteral pargv[1];
  pargv[0] = f;
  PtrOrLiteral nargv[6];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];
  nargv[5] = argv[5];
  
  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    // no pointer args to save
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    // no pointer args to restore
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN just right\n");
      #endif
      pushargs(6, nargv);
      // 0 pointers to push
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0, 6);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 pointers into new PAP\n");
      #endif
      // 0 pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+0], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN FUN just right\n");
      #endif
      pushargs(6, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      // 0 non-pointer args
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 0 + pappargc, 6 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new pointers into new PAP\n");
      #endif
      // 0 new pointers to insert into PAP
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+0+papnargc], nargv, 6);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[0];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[1];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[2];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  nargv[4] = argv[5];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[3];
  nargv[1] = argv[4];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[3];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];
  nargv[4] = argv[5];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[4];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[4];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[4];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPNN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[4];
  nargv[1] = argv[5];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPNN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[4];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[5];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[4] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[5];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[5];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[5];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[5];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[5];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[5];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPPN, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPN %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[5];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        // no excess pointer params to save
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        // no excess pointer params to restore
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyN, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPN, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPN, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPN, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPPN, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPN PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPN!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPN not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 1;
  PtrOrLiteral pargv[2];
  pargv[0] = argv[5];
  pargv[1] = f;
  PtrOrLiteral nargv[5];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  nargv[4] = argv[4];
  callContSave(2, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[5] = pargv[0];
  f = pargv[1];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(1, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[5] = pargv[0];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(1, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1, 5);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+1], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(5, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[5] = pargv[0];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP FUN just right\n");
      #endif
      pushargs(5, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(1, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 1 + pappargc, 5 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 1);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+1+papnargc], nargv, 5);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[0];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[5] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[5] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[1];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[5] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[5] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[2];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  nargv[3] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[5] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[5] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[3];
  nargv[1] = argv[4];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[3];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[4];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[5] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[5] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[4];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[4];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[4];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[4];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPNP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPNP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[5] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPNP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPNP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPNP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPNP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 2;
  PtrOrLiteral pargv[3];
  pargv[0] = argv[4];
  pargv[1] = argv[5];
  pargv[2] = f;
  PtrOrLiteral nargv[4];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  nargv[3] = argv[3];
  callContSave(3, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[4] = pargv[0];
  argv[5] = pargv[1];
  callContSave(3, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[4] = pargv[0];
  argv[5] = pargv[1];
  f = pargv[2];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(2, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[4] = pargv[0];
    argv[5] = pargv[1];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(2, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2, 4);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+2], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[1]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(4, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[4] = pargv[0];
        argv[5] = pargv[1];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP FUN just right\n");
      #endif
      pushargs(4, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(2, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 2 + pappargc, 4 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 2);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+2+papnargc], nargv, 4);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[0];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[1];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  nargv[2] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[2];
  nargv[1] = argv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[2];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[3];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPNPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPNPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[3];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPNPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPNPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPNPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPNPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 3;
  PtrOrLiteral pargv[4];
  pargv[0] = argv[3];
  pargv[1] = argv[4];
  pargv[2] = argv[5];
  pargv[3] = f;
  PtrOrLiteral nargv[3];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  nargv[2] = argv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  callContSave(4, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[3] = pargv[0];
  argv[4] = pargv[1];
  argv[5] = pargv[2];
  f = pargv[3];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(3, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[3] = pargv[0];
    argv[4] = pargv[1];
    argv[5] = pargv[2];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(3, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3, 3);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 3 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+3], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[2]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[1]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(3, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[3] = pargv[0];
        argv[4] = pargv[1];
        argv[5] = pargv[2];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP FUN just right\n");
      #endif
      pushargs(3, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(3, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 3 + pappargc, 3 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 3);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 3 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+3+papnargc], nargv, 3);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[0];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[1];
  nargv[1] = argv[2];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[1];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[2];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPNPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPNPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[2];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPNPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPNPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPNPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPNPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNNPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNNPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 4;
  PtrOrLiteral pargv[5];
  pargv[0] = argv[2];
  pargv[1] = argv[3];
  pargv[2] = argv[4];
  pargv[3] = argv[5];
  pargv[4] = f;
  PtrOrLiteral nargv[2];
  nargv[0] = argv[0];
  nargv[1] = argv[1];
  callContSave(5, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  callContSave(5, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[2] = pargv[0];
  argv[3] = pargv[1];
  argv[4] = pargv[2];
  argv[5] = pargv[3];
  f = pargv[4];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(4, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[2] = pargv[0];
    argv[3] = pargv[1];
    argv[4] = pargv[2];
    argv[5] = pargv[3];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(4, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4, 2);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 4 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 2 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+4], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[3]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[2]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[1]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(2, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[2] = pargv[0];
        argv[3] = pargv[1];
        argv[4] = pargv[2];
        argv[5] = pargv[3];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP FUN just right\n");
      #endif
      pushargs(2, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(4, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 4 + pappargc, 2 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 4 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 4);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 2 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+4+papnargc], nargv, 2);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPNPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPNPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[0];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[1];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyNPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyNPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPNPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPNPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPNPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyNPPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyNPPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 5;
  PtrOrLiteral pargv[6];
  pargv[0] = argv[1];
  pargv[1] = argv[2];
  pargv[2] = argv[3];
  pargv[3] = argv[4];
  pargv[4] = argv[5];
  pargv[5] = f;
  PtrOrLiteral nargv[1];
  nargv[0] = argv[0];
  callContSave(6, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  callContSave(6, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[1] = pargv[0];
  argv[2] = pargv[1];
  argv[3] = pargv[2];
  argv[4] = pargv[3];
  argv[5] = pargv[4];
  f = pargv[5];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(5, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[1] = pargv[0];
    argv[2] = pargv[1];
    argv[3] = pargv[2];
    argv[4] = pargv[3];
    argv[5] = pargv[4];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        // 0 pointers to push
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(5, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5, 1);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 5 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 1 non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+5], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[4]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[3]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[2]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[1]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[0]);
        // push needed args
        pushargs(1, nargv);
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        // 0 pointers to push
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[0]);
        // restore argv
        argv[1] = pargv[0];
        argv[2] = pargv[1];
        argv[3] = pargv[2];
        argv[4] = pargv[3];
        argv[5] = pargv[4];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP FUN just right\n");
      #endif
      pushargs(1, nargv);
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(5, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyNPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 5 + pappargc, 1 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 5 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 5);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 1 new non-pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+5+papnargc], nargv, 1);
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyNPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyNPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

DEFUN1(stgApplyPPPPPP, f) {
  #ifdef DEBUGSTGAPPLY
  fprintf(stderr, "stgApplyPPPPPP %s\n", getInfoPtr(f.op)->name);
  #endif
  const int argc = 6;
  PtrOrLiteral argv[6];
  popargs(argc, argv);
  const int nps = 6;
  PtrOrLiteral pargv[7];
  pargv[0] = argv[0];
  pargv[1] = argv[1];
  pargv[2] = argv[2];
  pargv[3] = argv[3];
  pargv[4] = argv[4];
  pargv[5] = argv[5];
  pargv[6] = f;
  // no non-pointer args to save
  callContSave(7, pargv);
  STGEVAL(pargv[0]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  callContSave(7, pargv);
  STGEVAL(pargv[1]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  callContSave(7, pargv);
  STGEVAL(pargv[2]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  callContSave(7, pargv);
  STGEVAL(pargv[3]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  callContSave(7, pargv);
  STGEVAL(pargv[4]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  callContSave(7, pargv);
  STGEVAL(pargv[5]);
  callContRestore(pargv);
  // restore argv
  argv[0] = pargv[0];
  argv[1] = pargv[1];
  argv[2] = pargv[2];
  argv[3] = pargv[3];
  argv[4] = pargv[4];
  argv[5] = pargv[5];
  f = pargv[6];

  f.op = derefPoL(f);
  if (f.op->objType == THUNK) {
    callContSave(6, pargv);
    while (f.op->objType == THUNK) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP THUNK\n");
      #endif
      STGEVAL(f);
      // f.op = derefPoL(f);
      f.op = derefPoL(stgCurVal); 
    } // while THUNK
    callContRestore(pargv);
    // restore argv
    argv[0] = pargv[0];
    argv[1] = pargv[1];
    argv[2] = pargv[2];
    argv[3] = pargv[3];
    argv[4] = pargv[4];
    argv[5] = pargv[5];
  } // if THUNK

  switch (f.op->objType) {
  case FUN: {
    int arity = getInfoPtr(f.op)->funFields.arity;
    #ifdef DEBUGSTGAPPLY
    fprintf(stderr, "FUN %s arity %d\n", getInfoPtr(f.op)->name, getInfoPtr(f.op)->funFields.arity);
    #endif
    int excess = argc - arity;  // may be negative

    // too many args
    if (excess > 0) {
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(5, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(4, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(3, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(2, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply FUN 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(1, pargv);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply
        STGJUMP1(stgApplyPPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN just right\n");
      #endif
      // 0 non-pointers to push
      pushargs(6, pargv);
      // tail call the fun
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);
    }
    // excess < 0, too few args
    else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN too few args\n");
      #endif
      int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                    getInfoPtr(f.op)->layoutInfo.unboxedCount;
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 6, 0);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pargs to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 6 pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply FUN inserting 0 non-pointers into new PAP\n");
      #endif
      // 0 non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case FUN

  case PAP: {
    int fvCount = getInfoPtr(f.op)->layoutInfo.boxedCount + 
                  getInfoPtr(f.op)->layoutInfo.unboxedCount;
    int pappargc, papnargc;
    PNUNPACK(f.op->payload[fvCount].i, pappargc, papnargc);
    int argCount = pappargc + papnargc;
    int arity = getInfoPtr(f.op)->funFields.arity - argCount;
    int excess = argc - arity;

    // too many args
    if (excess > 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too many args\n");
      #endif
      switch (excess) {
      case 1: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 1 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(1, &pargv[5]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(5, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[5]);
        // restore argv
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[5]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyP, f);
        break;
      } // case 1
      case 2: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 2 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(2, &pargv[4]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(4, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[4]);
        // restore argv
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[4]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPP, f);
        break;
      } // case 2
      case 3: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 3 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(3, &pargv[3]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(3, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[3]);
        // restore argv
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[3]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPP, f);
        break;
      } // case 3
      case 4: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 4 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(4, &pargv[2]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(2, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[2]);
        // restore argv
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[2]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPP, f);
        break;
      } // case 4
      case 5: {
        #ifdef DEBUGSTGAPPLY
        fprintf(stderr, "stgApply PAP to 5 excess args\n");
        #endif
        // stash excess pointer args
        callContSave(5, &pargv[1]);
        // push needed args
        // 0 non-pointers to push
        pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
        pushargs(1, pargv);
        pushargs(pappargc, &f.op->payload[fvCount+1]);
        // call-with-return the FUN
        STGCALL1(getInfoPtr(f.op)->entryCode, f);
        // restore excess args
        callContRestore(&pargv[1]);
        // restore argv
        argv[1] = pargv[1];
        argv[2] = pargv[2];
        argv[3] = pargv[3];
        argv[4] = pargv[4];
        argv[5] = pargv[5];
        // grab obj just returned
        f = stgCurVal;
        // new argc
        // push excess args
        pushargs(excess, &argv[1]);
        // try again - tail call stgApply 
        STGJUMP1(stgApplyPPPPP, f);
        break;
      } // case 5
        default: fprintf(stderr, "switch on excess reached default!\n"); exit(0);
      } // switch(excess)
    } else 

    // just right
    if (excess == 0) {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP FUN just right\n");
      #endif
      // 0 non-pointer args
      pushargs(papnargc, &f.op->payload[fvCount+1+pappargc]);
      pushargs(6, pargv);
      pushargs(pappargc, &f.op->payload[fvCount+1]);
      // tail call the FUN
      STGJUMP1(getInfoPtr(f.op)->entryCode, f);

    // excess < 0, too few args
    } else {
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApplyPPPPPP PAP too few args\n");
      #endif
      // stgNewHeapPAP puts layout info at payload[fvCount]
      Obj *pap = stgNewHeapPAP(getInfoPtr(f.op), 6 + pappargc, 0 + papnargc);
      // copy fvs
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d FVs into new PAP\n", fvCount);
      #endif
      copyargs(&pap->payload[0], &f.op->payload[0], fvCount);
      // copy pap pointers to just after fvs and layout info
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old pointers into new PAP\n", pappargc);
      #endif
      copyargs(&pap->payload[fvCount+1], &f.op->payload[fvCount+1], pappargc);
      // copy pargs to just after fvs, layout info, and old pointers
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 6 new pointers into new PAP\n");
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc], pargv, 6);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting %d old non-pointers into new PAP\n", papnargc);
      #endif
      copyargs(&pap->payload[fvCount+1+pappargc+6], &f.op->payload[fvCount+1+pappargc], papnargc);
      #ifdef DEBUGSTGAPPLY
      fprintf(stderr, "stgApply PAP inserting 0 new non-pointers into new PAP\n");
      #endif
      // 0 new non-pointers to insert into PAP
      STGRETURN1(HOTOPL(pap));
    } // if excess
  } // case PAP

  case BLACKHOLE: {
    fprintf(stderr, "infinite loop detected in stgApplyPPPPPP!\n");
    showStgHeap();
    exit(0);
  } // case BLACKHOLE

  default:
    fprintf(stderr, "stgApplyPPPPPP not a THUNK, FUN, or PAP\n");
    exit(0);
  }  // switch
  ENDFUN;
}

