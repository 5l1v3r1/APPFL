(StgNonRec)
  Test.$WMkStrict =
  (FUN) Upd: r
  [dt!EYaIzB]
    (Case) (App) dt!EYaIzB = dt!FYaIzB
      (AlgAlt) (DEFAULT) _ -> (ConApp) Test.MkStrict [dt!FYaIzB]
(StgNonRec)
  Test.twoOrThree =
  (FUN) Upd: r
  [b!GYaIzB]
    (Case) (App) b!GYaIzB = wild!HYaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (Lit) (MachInt) 2
        (DataAlt) APPFL.Types.True -> (Lit) (MachInt) 3
(StgNonRec)
  Test.f =
  (FUN) Upd: r
  [x!IYaIzB]
    (App) x!IYaIzB
(StgNonRec)
  Test.main =
  (THUNK) Upd: u
    (Let) let
      (StgNonRec)
        sat!JYaIzB =
        (CONish) APPFL.Integer.Type.S# [(MachInt) 3]
        Worker/Wrapper: APPFL.Integer.Type.$WS#
    in (App) APPFL.Base.fromInteger sat!JYaIzB
(StgNonRec)
  Test.strictN =
  (FUN) Upd: r
  [eta!BAAACB]
    (App) Test.$WMkStrict eta!BAAACB
(StgNonRec)
  Test.t# =
  (FUN) Upd: r
  [x!KYaIzB]
    (ConApp) APPFL.Prim.(#,#) [APPFL.Types.True, x!KYaIzB]
(StgNonRec)
  a!YHaIyB =
  (THUNK) Upd: u
    (Let) let
      (StgNonRec)
        sat!LYaIzB =
        (CONish) APPFL.Integer.Type.S# [(MachInt) 2]
        Worker/Wrapper: APPFL.Integer.Type.$WS#
    in (App) APPFL.Base.fromInteger sat!LYaIzB
(StgNonRec)
  Test.t1 =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) APPFL.Tuple.(,) [a!YHaIyB, eta!BAAACB]
(StgNonRec)
  a1!4TaIyB =
  (THUNK) Upd: u
    (Let) let
      (StgNonRec)
        sat!MYaIzB =
        (CONish) APPFL.Integer.Type.S# [(MachInt) 2]
        Worker/Wrapper: APPFL.Integer.Type.$WS#
    in (App) APPFL.Base.fromInteger sat!MYaIzB
(StgNonRec)
  a2!5TaIyB =
  (THUNK) Upd: u
    (Let) let
      (StgNonRec)
        sat!NYaIzB =
        (CONish) APPFL.Integer.Type.S# [(MachInt) 3]
        Worker/Wrapper: APPFL.Integer.Type.$WS#
    in (App) APPFL.Base.fromInteger sat!NYaIzB
(StgNonRec)
  Test.t =
  (CONish) APPFL.Tuple.(,) [a1!4TaIyB, a2!5TaIyB]
  Worker/Wrapper: APPFL.Tuple.(,)
(StgNonRec)
  Test.c =
  (FUN) Upd: r
  [i!OYaIzB, b!PYaIzB]
    (Let) let
      (StgNonRec)
        sat!VYaIzB =
        (THUNK) Upd: u
          (Let) let
            (StgNonRec)
              sat!UYaIzB =
              (CONish) APPFL.Integer.Type.S# [(MachInt) 15]
              Worker/Wrapper: APPFL.Integer.Type.$WS#
          in (App) APPFL.Base.fromInteger sat!UYaIzB
    in (Let) let
         (StgNonRec)
           sat!WYaIzB =
           (CONish) Test.C [sat!VYaIzB, APPFL.Types.False]
           Worker/Wrapper: Test.C
       in (Let) let
            (StgNonRec)
              sat!TYaIzB =
              (THUNK) Upd: u
                (Let) let
                  (StgNonRec)
                    sat!RYaIzB =
                    (THUNK) Upd: u
                      (Let) let
                        (StgNonRec)
                          sat!QYaIzB =
                          (CONish) APPFL.Integer.Type.S# [(MachInt) 2]
                          Worker/Wrapper: APPFL.Integer.Type.$WS#
                      in (App) APPFL.Base.fromInteger sat!QYaIzB
                in (Case) (App) APPFL.Classes.== i!OYaIzB sat!RYaIzB = wild!SYaIzB
                     (AlgAlt)
                       (DataAlt) APPFL.Types.False
                         -> (ConApp) Test.C [i!OYaIzB, APPFL.Types.False]
                       (DataAlt) APPFL.Types.True
                         -> (ConApp) Test.C [i!OYaIzB, APPFL.Types.True]
          in (App) APPFL.Base.ifThenElse b!PYaIzB sat!TYaIzB sat!WYaIzB
(StgNonRec)
  Test.MkStrict =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) Test.MkStrict [eta!BAAACB]
(StgNonRec)
  Test.C =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (ConApp) Test.C [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Base.quotRemInt =
  (FUN) Upd: r
  [ds!4YaIzB, ds1!5YaIzB]
    (Case) (App) ds!4YaIzB = wild!6YaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!7YaIzB
          -> (Case) (App) ds1!5YaIzB = wild1!8YaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!9YaIzB
                   -> (Case) (App) APPFL.Prim.quotRemInt# x1!7YaIzB y!9YaIzB = ds2!-YaIzB
                        (UbxTupAlt2)
                          (DataAlt) APPFL.Prim.(#,#) ipv!_YaIzB ipv1!AZaIzB
                            -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!_YaIzB,
                                                                 ipv1!AZaIzB] = wild2!BZaIzB
                                 (UbxTupAlt2)
                                   (DataAlt) APPFL.Prim.(#,#) q!CZaIzB r!DZaIzB
                                     -> (Let) let
                                          (StgNonRec)
                                            sat!FZaIzB =
                                            (CONish) APPFL.Types.I# [r!DZaIzB]
                                            Worker/Wrapper: APPFL.Types.I#
                                        in (Let) let
                                             (StgNonRec)
                                               sat!EZaIzB =
                                               (CONish) APPFL.Types.I# [q!CZaIzB]
                                               Worker/Wrapper: APPFL.Types.I#
                                           in (ConApp) APPFL.Tuple.(,) [sat!EZaIzB, sat!FZaIzB]
(StgNonRec)
  APPFL.Base.modInt =
  (FUN) Upd: r
  [ds!GZaIzB, ds1!HZaIzB]
    (Case) (App) ds!GZaIzB = wild!IZaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!JZaIzB
          -> (Case) (App) ds1!HZaIzB = wild1!KZaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!LZaIzB
                   -> (Case) (App) APPFL.Classes.modInt# x1!JZaIzB y!LZaIzB = wild2!MZaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!MZaIzB]
(StgNonRec)
  APPFL.Base.divInt =
  (FUN) Upd: r
  [ds!NZaIzB, ds1!OZaIzB]
    (Case) (App) ds!NZaIzB = wild!PZaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!QZaIzB
          -> (Case) (App) ds1!OZaIzB = wild1!RZaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!SZaIzB
                   -> (Case) (App) APPFL.Classes.divInt# x1!QZaIzB y!SZaIzB = wild2!TZaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!TZaIzB]
(StgNonRec)
  APPFL.Base.remInt =
  (FUN) Upd: r
  [eta!UZaIzB, eta1!VZaIzB]
    (Case) (App) eta!UZaIzB = wild!WZaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!XZaIzB
          -> (Case) (App) eta1!VZaIzB = wild1!YZaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!ZZaIzB
                   -> (Case) (App) APPFL.Prim.%# x1!XZaIzB y!ZZaIzB = wild2!aZaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!aZaIzB]
(StgNonRec)
  APPFL.Base.quotInt =
  (FUN) Upd: r
  [eta!bZaIzB, eta1!cZaIzB]
    (Case) (App) eta!bZaIzB = wild!dZaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!eZaIzB
          -> (Case) (App) eta1!cZaIzB = wild1!fZaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!gZaIzB
                   -> (Case) (App) APPFL.Prim./# x1!eZaIzB y!gZaIzB = wild2!hZaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!hZaIzB]
(StgNonRec)
  APPFL.Base.otherwise =
  (CONish) APPFL.Types.True []
  Worker/Wrapper: APPFL.Types.True
(StgNonRec)
  APPFL.Base.ifThenElse =
  (FUN) Upd: r
  [b!iZaIzB, t!jZaIzB, e!kZaIzB]
    (Case) (App) b!iZaIzB = wild!lZaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (App) e!kZaIzB
        (DataAlt) APPFL.Types.True -> (App) t!jZaIzB
(StgNonRec)
  APPFL.Base.divModInt# =
  (FUN) Upd: r
  [x#!mZaIzB, y#!nZaIzB]
    (Let) let
      (StgNonRec)
        sat!rZaIzB =
        (THUNK) Upd: u
          (Case) (Op) (Prim) <# [y#!nZaIzB, (MachInt) 0] = sat!qZaIzB
            (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!qZaIzB
    in (Let) let
         (StgNonRec)
           sat!pZaIzB =
           (THUNK) Upd: u
             (Case) (Op) (Prim) ># [x#!mZaIzB, (MachInt) 0] = sat!oZaIzB
               (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!oZaIzB
       in (Case) (App) APPFL.Classes.&& sat!pZaIzB sat!rZaIzB = wild!sZaIzB
            (AlgAlt)
              (DataAlt) APPFL.Types.False
                -> (Let) let
                     (StgNonRec)
                       sat!wZaIzB =
                       (THUNK) Upd: u
                         (Case) (Op) (Prim) ># [y#!nZaIzB, (MachInt) 0] = sat!vZaIzB
                           (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!vZaIzB
                   in (Let) let
                        (StgNonRec)
                          sat!uZaIzB =
                          (THUNK) Upd: u
                            (Case) (Op) (Prim) <# [x#!mZaIzB, (MachInt) 0] = sat!tZaIzB
                              (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!tZaIzB
                      in (Case) (App) APPFL.Classes.&& sat!uZaIzB sat!wZaIzB = wild1!xZaIzB
                           (AlgAlt)
                             (DataAlt) APPFL.Types.False
                               -> (App) APPFL.Prim.quotRemInt# x#!mZaIzB y#!nZaIzB
                             (DataAlt) APPFL.Types.True
                               -> (Case) (Op) (Prim) +# [x#!mZaIzB, (MachInt) 1] = sat!yZaIzB
                                    (PrimAlt)
                                      (DEFAULT) _
                                        -> (Case) (App) APPFL.Prim.quotRemInt# sat!yZaIzB y#!nZaIzB = ds!zZaIzB
                                             (UbxTupAlt2)
                                               (DataAlt) APPFL.Prim.(#,#) ipv!0ZaIzB ipv1!1ZaIzB
                                                 -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!0ZaIzB,
                                                                                      ipv1!1ZaIzB] = wild2!2ZaIzB
                                                      (UbxTupAlt2)
                                                        (DataAlt) APPFL.Prim.(#,#) q!3ZaIzB r!4ZaIzB
                                                          -> (Case) (Op) (Prim) +# [r!4ZaIzB,
                                                                                    y#!nZaIzB] = sat!6ZaIzB
                                                               (PrimAlt)
                                                                 (DEFAULT) _
                                                                   -> (Case) (Op) (Prim) -# [sat!6ZaIzB,
                                                                                             (MachInt) 1] = sat!7ZaIzB
                                                                        (PrimAlt)
                                                                          (DEFAULT) _
                                                                            -> (Case) (Op) (Prim) -# [q!3ZaIzB,
                                                                                                      (MachInt) 1] = sat!5ZaIzB
                                                                                 (PrimAlt)
                                                                                   (DEFAULT) _
                                                                                     -> (ConApp) APPFL.Prim.(#,#) [sat!5ZaIzB,
                                                                                                                   sat!7ZaIzB]
              (DataAlt) APPFL.Types.True
                -> (Case) (Op) (Prim) -# [x#!mZaIzB, (MachInt) 1] = sat!8ZaIzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Prim.quotRemInt# sat!8ZaIzB y#!nZaIzB = ds!9ZaIzB
                              (UbxTupAlt2)
                                (DataAlt) APPFL.Prim.(#,#) ipv!-ZaIzB ipv1!_ZaIzB
                                  -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!-ZaIzB,
                                                                       ipv1!_ZaIzB] = wild1!AaaIzB
                                       (UbxTupAlt2)
                                         (DataAlt) APPFL.Prim.(#,#) q!BaaIzB r!CaaIzB
                                           -> (Case) (Op) (Prim) +# [r!CaaIzB,
                                                                     y#!nZaIzB] = sat!EaaIzB
                                                (PrimAlt)
                                                  (DEFAULT) _
                                                    -> (Case) (Op) (Prim) +# [sat!EaaIzB,
                                                                              (MachInt) 1] = sat!FaaIzB
                                                         (PrimAlt)
                                                           (DEFAULT) _
                                                             -> (Case) (Op) (Prim) -# [q!BaaIzB,
                                                                                       (MachInt) 1] = sat!DaaIzB
                                                                  (PrimAlt)
                                                                    (DEFAULT) _
                                                                      -> (ConApp) APPFL.Prim.(#,#) [sat!DaaIzB,
                                                                                                    sat!FaaIzB]
(StgNonRec)
  APPFL.Base.divModInt =
  (FUN) Upd: r
  [ds!GaaIzB, ds1!HaaIzB]
    (Case) (App) ds!GaaIzB = wild!IaaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!JaaIzB
          -> (Case) (App) ds1!HaaIzB = wild1!KaaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!LaaIzB
                   -> (Case) (App) APPFL.Base.divModInt# x1!JaaIzB y!LaaIzB = ds2!MaaIzB
                        (UbxTupAlt2)
                          (DataAlt) APPFL.Prim.(#,#) ipv!NaaIzB ipv1!OaaIzB
                            -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!NaaIzB,
                                                                 ipv1!OaaIzB] = wild2!PaaIzB
                                 (UbxTupAlt2)
                                   (DataAlt) APPFL.Prim.(#,#) q!QaaIzB r!RaaIzB
                                     -> (Let) let
                                          (StgNonRec)
                                            sat!TaaIzB =
                                            (CONish) APPFL.Types.I# [r!RaaIzB]
                                            Worker/Wrapper: APPFL.Types.I#
                                        in (Let) let
                                             (StgNonRec)
                                               sat!SaaIzB =
                                               (CONish) APPFL.Types.I# [q!QaaIzB]
                                               Worker/Wrapper: APPFL.Types.I#
                                           in (ConApp) APPFL.Tuple.(,) [sat!SaaIzB, sat!TaaIzB]
(StgRec)
  x!9TaIyB =
  (THUNK) Upd: u (App) x!9TaIyB
(StgNonRec)
  APPFL.Base._dummy =
  (THUNK) Upd: u (App) x!9TaIyB
(StgNonRec)
  APPFL.Base.fromInteger =
  (THUNK) Upd: u (App) x!9TaIyB
(StgNonRec)
  APPFL.Num.mulInt =
  (FUN) Upd: r
  [ds!McaIzB, ds1!NcaIzB]
    (Case) (App) ds!McaIzB = wild!OcaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!PcaIzB
          -> (Case) (App) ds1!NcaIzB = wild1!QcaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!RcaIzB
                   -> (Case) (Op) (Prim) *# [a#!PcaIzB, b#!RcaIzB] = sat!ScaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!ScaIzB]
(StgNonRec)
  APPFL.Num.subInt =
  (FUN) Upd: r
  [ds!TcaIzB, ds1!UcaIzB]
    (Case) (App) ds!TcaIzB = wild!VcaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!WcaIzB
          -> (Case) (App) ds1!UcaIzB = wild1!XcaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!YcaIzB
                   -> (Case) (Op) (Prim) -# [a#!WcaIzB, b#!YcaIzB] = sat!ZcaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!ZcaIzB]
(StgNonRec)
  APPFL.Num.addInt =
  (FUN) Upd: r
  [ds!acaIzB, ds1!bcaIzB]
    (Case) (App) ds!acaIzB = wild!ccaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!dcaIzB
          -> (Case) (App) ds1!bcaIzB = wild1!ecaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!fcaIzB
                   -> (Case) (Op) (Prim) +# [a#!dcaIzB, b#!fcaIzB] = sat!gcaIzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!gcaIzB]
(StgNonRec)
  APPFL.Num.negate =
  (FUN) Upd: r
  [ds!hcaIzB]
    (Case) (App) ds!hcaIzB = wild!icaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# i#!jcaIzB
          -> (Case) (Op) (Prim) negateInt# [i#!jcaIzB] = sat!kcaIzB
               (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!kcaIzB]
(StgNonRec)
  APPFL.Num.% =
  (THUNK) Upd: u (App) APPFL.Base.remInt
(StgNonRec)
  APPFL.Num.mod =
  (THUNK) Upd: u (App) APPFL.Base.remInt
(StgNonRec)
  APPFL.Num.* =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.mulInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Num./ =
  (THUNK) Upd: u (App) APPFL.Base.quotInt
(StgNonRec)
  APPFL.Num.div =
  (THUNK) Upd: u (App) APPFL.Base.quotInt
(StgNonRec)
  APPFL.Num.- =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.subInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Num.+ =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.addInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Types.isTrue# =
  (FUN) Upd: r
  [ds!TdaIzB]
    (Case) (App) ds!TdaIzB = ds1!UdaIzB
      (PrimAlt)
        (DEFAULT) _ -> (ConApp) APPFL.Types.False []
        (LitAlt) (MachInt) 1 -> (ConApp) APPFL.Types.True []
(StgNonRec)
  APPFL.Types.MkCoercible =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) APPFL.Types.MkCoercible [APPFL.Prim.coercionToken#]
(StgNonRec)
  APPFL.Types.Cons =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (ConApp) APPFL.Types.Cons [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Types.Nil =
  (CONish) APPFL.Types.Nil []
  Worker/Wrapper: APPFL.Types.Nil
(StgNonRec)
  APPFL.Types.Unit =
  (CONish) APPFL.Types.Unit []
  Worker/Wrapper: APPFL.Types.Unit
(StgNonRec)
  APPFL.Types.I# =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) APPFL.Types.I# [eta!BAAACB]
(StgNonRec)
  APPFL.Types.False =
  (CONish) APPFL.Types.False []
  Worker/Wrapper: APPFL.Types.False
(StgNonRec)
  APPFL.Types.True =
  (CONish) APPFL.Types.True []
  Worker/Wrapper: APPFL.Types.True
(StgRec)
  APPFL.Prim.imin# =
  (THUNK) Upd: u (App) x!jdaIyB
  x!jdaIyB =
  (THUNK) Upd: u (App) APPFL.Prim.imin#
(StgRec)
  APPFL.Prim.imax# =
  (THUNK) Upd: u (App) x1!kdaIyB
  x1!kdaIyB =
  (THUNK) Upd: u (App) APPFL.Prim.imax#
(StgNonRec)
  APPFL.Prim.ineg# =
  (FUN) Upd: r
  [eta!BAAACB]
    (Op) (Prim) negateInt# [eta!BAAACB]
(StgNonRec)
  APPFL.Prim./# =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (Op) (Prim) quotInt# [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Prim.%# =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (Op) (Prim) remInt# [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Prim.quotRemInt# =
  (FUN) Upd: r
  [a!ldaIzB, b!mdaIzB]
    (Case) (Op) (Prim) quotInt# [a!ldaIzB, b!mdaIzB] = q!ndaIzB
      (PrimAlt)
        (DEFAULT) _
          -> (Case) (Op) (Prim) remInt# [a!ldaIzB, b!mdaIzB] = r!odaIzB
               (PrimAlt)
                 (DEFAULT) _ -> (ConApp) APPFL.Prim.(#,#) [q!ndaIzB, r!odaIzB]
(StgNonRec)
  APPFL.Classes.not =
  (FUN) Upd: r
  [ds!9daIzB]
    (Case) (App) ds!9daIzB = wild!-daIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (ConApp) APPFL.Types.True []
        (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.False []
(StgNonRec)
  APPFL.Classes.|| =
  (FUN) Upd: r
  [ds!_daIzB, ds1!AeaIzB]
    (Case) (App) ds!_daIzB = wild!BeaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (App) ds1!AeaIzB
        (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.True []
(StgNonRec)
  APPFL.Classes.&& =
  (FUN) Upd: r
  [ds!CeaIzB, x!DeaIzB]
    (Case) (App) ds!CeaIzB = wild!EeaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (ConApp) APPFL.Types.False []
        (DataAlt) APPFL.Types.True -> (App) x!DeaIzB
(StgNonRec)
  APPFL.Classes.divInt# =
  (FUN) Upd: r
  [x#!FeaIzB, y#!GeaIzB]
    (LetNE) let
      (StgNonRec)
        $j!HeaIzB =
        (FUN) Upd: r
        [w!IeaIzB]
          (Case) (Op) (Prim) <# [x#!FeaIzB, (MachInt) 0] = sat!JeaIzB
            (PrimAlt)
              (DEFAULT) _
                -> (Case) (App) APPFL.Types.isTrue# sat!JeaIzB = wild!KeaIzB
                     (AlgAlt)
                       (DataAlt) APPFL.Types.False
                         -> (Op) (Prim) quotInt# [x#!FeaIzB, y#!GeaIzB]
                       (DataAlt) APPFL.Types.True
                         -> (Case) (Op) (Prim) ># [y#!GeaIzB, (MachInt) 0] = sat!LeaIzB
                              (PrimAlt)
                                (DEFAULT) _
                                  -> (Case) (App) APPFL.Types.isTrue# sat!LeaIzB = wild1!MeaIzB
                                       (AlgAlt)
                                         (DataAlt) APPFL.Types.False
                                           -> (Op) (Prim) quotInt# [x#!FeaIzB, y#!GeaIzB]
                                         (DataAlt) APPFL.Types.True
                                           -> (Case) (Op) (Prim) +# [x#!FeaIzB,
                                                                     (MachInt) 1] = sat!NeaIzB
                                                (PrimAlt)
                                                  (DEFAULT) _
                                                    -> (Case) (Op) (Prim) quotInt# [sat!NeaIzB,
                                                                                    y#!GeaIzB] = wild2!OeaIzB
                                                         (PrimAlt)
                                                           (DEFAULT) _
                                                             -> (Op) (Prim) -# [wild2!OeaIzB,
                                                                                (MachInt) 1]
    in (Case) (Op) (Prim) ># [x#!FeaIzB, (MachInt) 0] = sat!PeaIzB
         (PrimAlt)
           (DEFAULT) _
             -> (Case) (App) APPFL.Types.isTrue# sat!PeaIzB = wild!QeaIzB
                  (AlgAlt)
                    (DataAlt) APPFL.Types.False -> (App) $j!HeaIzB APPFL.Prim.void#
                    (DataAlt) APPFL.Types.True
                      -> (Case) (Op) (Prim) <# [y#!GeaIzB, (MachInt) 0] = sat!ReaIzB
                           (PrimAlt)
                             (DEFAULT) _
                               -> (Case) (App) APPFL.Types.isTrue# sat!ReaIzB = wild1!SeaIzB
                                    (AlgAlt)
                                      (DataAlt) APPFL.Types.False
                                        -> (App) $j!HeaIzB APPFL.Prim.void#
                                      (DataAlt) APPFL.Types.True
                                        -> (Case) (Op) (Prim) -# [x#!FeaIzB,
                                                                  (MachInt) 1] = sat!TeaIzB
                                             (PrimAlt)
                                               (DEFAULT) _
                                                 -> (Case) (Op) (Prim) quotInt# [sat!TeaIzB,
                                                                                 y#!GeaIzB] = wild2!UeaIzB
                                                      (PrimAlt)
                                                        (DEFAULT) _
                                                          -> (Op) (Prim) -# [wild2!UeaIzB,
                                                                             (MachInt) 1]
(StgNonRec)
  APPFL.Classes.modInt# =
  (FUN) Upd: r
  [x#!VeaIzB, y#!WeaIzB]
    (Case) (Op) (Prim) remInt# [x#!VeaIzB, y#!WeaIzB] = r#!XeaIzB
      (PrimAlt)
        (DEFAULT) _
          -> (LetNE) let
               (StgNonRec)
                 $j!YeaIzB =
                 (FUN) Upd: r
                 [w!ZeaIzB]
                   (Case) (App) r#!XeaIzB = wild!aeaIzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Types.isTrue# (MachInt) 1 = wild1!beaIzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (Lit) (MachInt) 0
                                (DataAlt) APPFL.Types.True
                                  -> (Op) (Prim) +# [wild!aeaIzB, y#!WeaIzB]
                       (LitAlt) (MachInt) 0
                         -> (Case) (App) APPFL.Types.isTrue# (MachInt) 0 = wild1!ceaIzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (Lit) (MachInt) 0
                                (DataAlt) APPFL.Types.True -> (App) y#!WeaIzB
             in (LetNE) let
                  (StgNonRec)
                    $j1!deaIzB =
                    (FUN) Upd: r
                    [w!eeaIzB]
                      (Case) (Op) (Prim) <# [x#!VeaIzB, (MachInt) 0] = sat!feaIzB
                        (PrimAlt)
                          (DEFAULT) _
                            -> (Case) (App) APPFL.Types.isTrue# sat!feaIzB = wild!geaIzB
                                 (AlgAlt)
                                   (DataAlt) APPFL.Types.False -> (App) r#!XeaIzB
                                   (DataAlt) APPFL.Types.True
                                     -> (Case) (Op) (Prim) ># [y#!WeaIzB, (MachInt) 0] = sat!heaIzB
                                          (PrimAlt)
                                            (DEFAULT) _
                                              -> (Case) (App) APPFL.Types.isTrue# sat!heaIzB = wild1!ieaIzB
                                                   (AlgAlt)
                                                     (DataAlt) APPFL.Types.False -> (App) r#!XeaIzB
                                                     (DataAlt) APPFL.Types.True
                                                       -> (App) $j!YeaIzB APPFL.Prim.void#
                in (Case) (Op) (Prim) ># [x#!VeaIzB, (MachInt) 0] = sat!jeaIzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Types.isTrue# sat!jeaIzB = wild!keaIzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (App) $j1!deaIzB APPFL.Prim.void#
                                (DataAlt) APPFL.Types.True
                                  -> (Case) (Op) (Prim) <# [y#!WeaIzB, (MachInt) 0] = sat!leaIzB
                                       (PrimAlt)
                                         (DEFAULT) _
                                           -> (Case) (App) APPFL.Types.isTrue# sat!leaIzB = wild1!meaIzB
                                                (AlgAlt)
                                                  (DataAlt) APPFL.Types.False
                                                    -> (App) $j1!deaIzB APPFL.Prim.void#
                                                  (DataAlt) APPFL.Types.True
                                                    -> (App) $j!YeaIzB APPFL.Prim.void#
(StgNonRec)
  APPFL.Classes.leInt =
  (FUN) Upd: r
  [eta!neaIzB, eta1!oeaIzB]
    (Case) (App) eta!neaIzB = wild!peaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!qeaIzB
          -> (Case) (App) eta1!oeaIzB = wild1!reaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!seaIzB
                   -> (Case) (Op) (Prim) <=# [x!qeaIzB, y!seaIzB] = sat!teaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!teaIzB
(StgNonRec)
  APPFL.Classes.ltInt =
  (FUN) Upd: r
  [eta!ueaIzB, eta1!veaIzB]
    (Case) (App) eta!ueaIzB = wild!weaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!xeaIzB
          -> (Case) (App) eta1!veaIzB = wild1!yeaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!zeaIzB
                   -> (Case) (Op) (Prim) <# [x!xeaIzB, y!zeaIzB] = sat!0eaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!0eaIzB
(StgNonRec)
  APPFL.Classes.geInt =
  (FUN) Upd: r
  [eta!1eaIzB, eta1!2eaIzB]
    (Case) (App) eta!1eaIzB = wild!3eaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!4eaIzB
          -> (Case) (App) eta1!2eaIzB = wild1!5eaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!6eaIzB
                   -> (Case) (Op) (Prim) >=# [x!4eaIzB, y!6eaIzB] = sat!7eaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!7eaIzB
(StgNonRec)
  APPFL.Classes.gtInt =
  (FUN) Upd: r
  [eta!8eaIzB, eta1!9eaIzB]
    (Case) (App) eta!8eaIzB = wild!-eaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!_eaIzB
          -> (Case) (App) eta1!9eaIzB = wild1!AfaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!BfaIzB
                   -> (Case) (Op) (Prim) ># [x!_eaIzB, y!BfaIzB] = sat!CfaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!CfaIzB
(StgNonRec)
  APPFL.Classes.neInt =
  (FUN) Upd: r
  [eta!DfaIzB, eta1!EfaIzB]
    (Case) (App) eta!DfaIzB = wild!FfaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!GfaIzB
          -> (Case) (App) eta1!EfaIzB = wild1!HfaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!IfaIzB
                   -> (Case) (Op) (Prim) /=# [x!GfaIzB, y!IfaIzB] = sat!JfaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!JfaIzB
(StgNonRec)
  APPFL.Classes.eqInt =
  (FUN) Upd: r
  [eta!KfaIzB, eta1!LfaIzB]
    (Case) (App) eta!KfaIzB = wild!MfaIzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!NfaIzB
          -> (Case) (App) eta1!LfaIzB = wild1!OfaIzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!PfaIzB
                   -> (Case) (Op) (Prim) ==# [x!NfaIzB, y!PfaIzB] = sat!QfaIzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!QfaIzB
(StgNonRec)
  APPFL.Classes.== =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Classes.eqInt eta!CAAACB eta!BAAACB