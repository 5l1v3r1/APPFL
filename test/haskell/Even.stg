[1 of 1] Compiling Even             ( Even.hs, Even.o )

==================== STG syntax: ====================
sat_s1ad :: GHC.Integer.Type.Integer =
    NO_CCS GHC.Integer.Type.S#! [6];
sat_s1ac :: GHC.Integer.Type.Integer =
    NO_CCS GHC.Integer.Type.S#! [1];
Even.someList :: [GHC.Integer.Type.Integer] =
    \u srt:SRT:[rUF :-> GHC.Enum.$fEnumInteger,
                s1ac :-> sat_s1ac, s1ad :-> sat_s1ad] []
        GHC.Enum.enumFromTo
            GHC.Enum.$fEnumInteger sat_s1ac sat_s1ad;
$cshowsPrec_r12z
  :: forall a_a189 b_a18a.
     (GHC.Show.Show a_a189, GHC.Show.Show b_a18a) =>
     GHC.Types.Int -> Even.TorJ a_a189 b_a18a -> GHC.Show.ShowS =
    sat-only \r srt:SRT:[0k :-> GHC.CString.unpackCString#,
                         r1R :-> GHC.Show.showString, r1S :-> GHC.Show.showParen,
                         r2C :-> GHC.Base..,
                         ruB :-> GHC.Classes.$fOrdInt] [$dShow_s1ae
                                                        $dShow1_s1af
                                                        a1_s1ag
                                                        ds_s1ah]
        case ds_s1ah of _ {
          Even.Treasure b1_s1aj ->
              let {
                sat_s1aq :: GHC.Show.ShowS =
                    \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                r1R :-> GHC.Show.showString, r2C :-> GHC.Base..] []
                        let {
                          sat_s1ap :: GHC.Base.String -> GHC.Base.String =
                              \u srt:SRT:[] []
                                  let {
                                    sat_s1ao :: GHC.Types.Int = NO_CCS GHC.Types.I#! [11];
                                  } in 
                                    GHC.Show.showsPrec $dShow_s1ae sat_s1ao b1_s1aj; } in
                        let {
                          sat_s1an :: GHC.Base.String -> GHC.Base.String =
                              \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                          r1R :-> GHC.Show.showString] []
                                  let {
                                    sat_s1am :: GHC.Base.String =
                                        \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                            GHC.CString.unpackCString# "Treasure "#;
                                  } in  GHC.Show.showString sat_s1am;
                        } in  GHC.Base.. sat_s1an sat_s1ap; } in
              let {
                sat_s1al :: GHC.Types.Bool =
                    \u srt:SRT:[ruB :-> GHC.Classes.$fOrdInt] []
                        let { sat_s1ak :: GHC.Types.Int = NO_CCS GHC.Types.I#! [11];
                        } in  GHC.Classes.>= GHC.Classes.$fOrdInt a1_s1ag sat_s1ak;
              } in  GHC.Show.showParen sat_s1al sat_s1aq;
          Even.Junk b1_s1ar ->
              let {
                sat_s1ay :: GHC.Show.ShowS =
                    \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                r1R :-> GHC.Show.showString, r2C :-> GHC.Base..] []
                        let {
                          sat_s1ax :: GHC.Base.String -> GHC.Base.String =
                              \u srt:SRT:[] []
                                  let {
                                    sat_s1aw :: GHC.Types.Int = NO_CCS GHC.Types.I#! [11];
                                  } in 
                                    GHC.Show.showsPrec $dShow1_s1af sat_s1aw b1_s1ar; } in
                        let {
                          sat_s1av :: GHC.Base.String -> GHC.Base.String =
                              \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                          r1R :-> GHC.Show.showString] []
                                  let {
                                    sat_s1au :: GHC.Base.String =
                                        \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                            GHC.CString.unpackCString# "Junk "#;
                                  } in  GHC.Show.showString sat_s1au;
                        } in  GHC.Base.. sat_s1av sat_s1ax; } in
              let {
                sat_s1at :: GHC.Types.Bool =
                    \u srt:SRT:[ruB :-> GHC.Classes.$fOrdInt] []
                        let { sat_s1as :: GHC.Types.Int = NO_CCS GHC.Types.I#! [11];
                        } in  GHC.Classes.>= GHC.Classes.$fOrdInt a1_s1ag sat_s1as;
              } in  GHC.Show.showParen sat_s1at sat_s1ay;
        };
Even.$fShowTorJ
  :: forall a_aU7 b_aU8.
     (GHC.Show.Show a_aU7, GHC.Show.Show b_aU8) =>
     GHC.Show.Show (Even.TorJ a_aU7 b_aU8) =
    \r srt:SRT:[r12z :-> $cshowsPrec_r12z,
                r1a9 :-> $cshowList_r1a9, r1aa :-> $cshow_r1aa] [$dShow_s1az
                                                                 $dShow1_s1aA]
        let {
          sat_s1aD :: [Even.TorJ a_a189 b_a18a] -> GHC.Show.ShowS =
              \u srt:SRT:[r1a9 :-> $cshowList_r1a9] []
                  $cshowList_r1a9 $dShow_s1az $dShow1_s1aA; } in
        let {
          sat_s1aC :: Even.TorJ a_a189 b_a18a -> GHC.Base.String =
              \u srt:SRT:[r1aa :-> $cshow_r1aa] []
                  $cshow_r1aa $dShow_s1az $dShow1_s1aA; } in
        let {
          sat_s1aB
            :: GHC.Types.Int
               -> Even.TorJ a_a189 b_a18a -> GHC.Show.ShowS =
              \r srt:SRT:[r12z :-> $cshowsPrec_r12z] [eta_B2 eta_B1]
                  $cshowsPrec_r12z $dShow_s1az $dShow1_s1aA eta_B2 eta_B1;
        } in  GHC.Show.D:Show [sat_s1aB sat_s1aC sat_s1aD];
$cshowList_r1a9
  :: forall a_a189 b_a18a.
     (GHC.Show.Show a_a189, GHC.Show.Show b_a18a) =>
     [Even.TorJ a_a189 b_a18a] -> GHC.Show.ShowS =
    \r srt:SRT:[rbU :-> GHC.Show.showList__,
                rJ0 :-> Even.$fShowTorJ] [$dShow_s1aE $dShow1_s1aF]
        let {
          sat_s1aI :: Even.TorJ a_a189 b_a18a -> GHC.Show.ShowS =
              \u srt:SRT:[rJ0 :-> Even.$fShowTorJ] []
                  let { sat_s1aH :: GHC.Types.Int = NO_CCS GHC.Types.I#! [0];
                  } in 
                    case Even.$fShowTorJ $dShow_s1aE $dShow1_s1aF of sat_s1aG {
                      __DEFAULT -> GHC.Show.showsPrec sat_s1aG sat_s1aH;
                    };
        } in  GHC.Show.showList__ sat_s1aI;
$cshow_r1aa
  :: forall a_a189 b_a18a.
     (GHC.Show.Show a_a189, GHC.Show.Show b_a18a) =>
     Even.TorJ a_a189 b_a18a -> GHC.Base.String =
    \r srt:SRT:[rpG :-> GHC.Show.$dmshow,
                rJ0 :-> Even.$fShowTorJ] [$dShow_s1aJ $dShow1_s1aK]
        let {
          sat_s1aL :: GHC.Show.Show (Even.TorJ a_a189 b_a18a) =
              \u srt:SRT:[rJ0 :-> Even.$fShowTorJ] []
                  Even.$fShowTorJ $dShow_s1aJ $dShow1_s1aK;
        } in  GHC.Show.$dmshow sat_s1aL;
Even.parity :: GHC.Types.Int -> Even.Parity =
    \r srt:SRT:[r2C :-> GHC.Base..,
                ruB :-> GHC.Classes.$fOrdInt,
                rHs :-> GHC.Num.$fNumInt] [n1_s1aM]
        let {
          toZero_s1aN
            :: forall a_a14z.
               (GHC.Num.Num a_a14z, GHC.Classes.Ord a_a14z) =>
               a_a14z -> a_a14z =
              sat-only \r srt:SRT:[] [$dNum_s1aO $dOrd_s1aP n2_s1aQ]
                  let {
                    sat_s1aS :: a_a14D =
                        \u srt:SRT:[] []
                            let {
                              sat_s1aR :: GHC.Integer.Type.Integer =
                                  NO_CCS GHC.Integer.Type.S#! [0];
                            } in  GHC.Num.fromInteger $dNum_s1aO sat_s1aR;
                  } in 
                    case GHC.Classes.> $dOrd_s1aP n2_s1aQ sat_s1aS of _ {
                      GHC.Types.False ->
                          let {
                            sat_s1aV :: a_a14D =
                                \u srt:SRT:[] []
                                    let {
                                      sat_s1aU :: GHC.Integer.Type.Integer =
                                          NO_CCS GHC.Integer.Type.S#! [1];
                                    } in  GHC.Num.fromInteger $dNum_s1aO sat_s1aU;
                          } in  GHC.Num.+ $dNum_s1aO n2_s1aQ sat_s1aV;
                      GHC.Types.True ->
                          let {
                            sat_s1aX :: a_a14D =
                                \u srt:SRT:[] []
                                    let {
                                      sat_s1aW :: GHC.Integer.Type.Integer =
                                          NO_CCS GHC.Integer.Type.S#! [1];
                                    } in  GHC.Num.fromInteger $dNum_s1aO sat_s1aW;
                          } in  GHC.Num.- $dNum_s1aO n2_s1aQ sat_s1aX;
                    }; } in
        let {
          $dEq_s1aY :: GHC.Classes.Eq GHC.Types.Int =
              \u srt:SRT:[ruB :-> GHC.Classes.$fOrdInt] []
                  GHC.Classes.$p1Ord GHC.Classes.$fOrdInt; } in
        let {
          odd_s1aZ :: GHC.Types.Int -> GHC.Types.Bool =
              \r srt:SRT:[r2C :-> GHC.Base..,
                          ruB :-> GHC.Classes.$fOrdInt,
                          rHs :-> GHC.Num.$fNumInt] [ds_s1b1]
                  let {
                    sat_s1b3 :: GHC.Types.Int =
                        \u srt:SRT:[rHs :-> GHC.Num.$fNumInt] []
                            let {
                              sat_s1b2 :: GHC.Integer.Type.Integer =
                                  NO_CCS GHC.Integer.Type.S#! [0];
                            } in  GHC.Num.fromInteger GHC.Num.$fNumInt sat_s1b2;
                  } in 
                    case GHC.Classes.== $dEq_s1aY ds_s1b1 sat_s1b3 of _ {
                      GHC.Types.False ->
                          let {
                            sat_s1b5 :: GHC.Types.Int -> GHC.Types.Int =
                                \r srt:SRT:[ruB :-> GHC.Classes.$fOrdInt,
                                            rHs :-> GHC.Num.$fNumInt] [eta_B1]
                                    toZero_s1aN
                                        GHC.Num.$fNumInt GHC.Classes.$fOrdInt eta_B1;
                          } in  GHC.Base.. even_s1b0 sat_s1b5 ds_s1b1;
                      GHC.Types.True -> GHC.Types.False [];
                    };
          even_s1b0 :: GHC.Types.Int -> GHC.Types.Bool =
              \r srt:SRT:[r2C :-> GHC.Base..,
                          ruB :-> GHC.Classes.$fOrdInt,
                          rHs :-> GHC.Num.$fNumInt] [ds_s1b6]
                  let {
                    sat_s1b8 :: GHC.Types.Int =
                        \u srt:SRT:[rHs :-> GHC.Num.$fNumInt] []
                            let {
                              sat_s1b7 :: GHC.Integer.Type.Integer =
                                  NO_CCS GHC.Integer.Type.S#! [0];
                            } in  GHC.Num.fromInteger GHC.Num.$fNumInt sat_s1b7;
                  } in 
                    case GHC.Classes.== $dEq_s1aY ds_s1b6 sat_s1b8 of _ {
                      GHC.Types.False ->
                          let {
                            sat_s1ba :: GHC.Types.Int -> GHC.Types.Int =
                                \r srt:SRT:[ruB :-> GHC.Classes.$fOrdInt,
                                            rHs :-> GHC.Num.$fNumInt] [eta_B1]
                                    toZero_s1aN
                                        GHC.Num.$fNumInt GHC.Classes.$fOrdInt eta_B1;
                          } in  GHC.Base.. odd_s1aZ sat_s1ba ds_s1b6;
                      GHC.Types.True -> GHC.Types.True [];
                    };
        } in 
          case even_s1b0 n1_s1aM of _ {
            GHC.Types.False -> Even.Odd [];
            GHC.Types.True -> Even.Even [];
          };
Even.nValue
  :: GHC.Types.Int -> Even.TorJ GHC.Types.Int GHC.Types.Int =
    \r srt:SRT:[rlC :-> Even.parity] [n1_s1bc]
        case Even.parity n1_s1bc of _ {
          Even.Even -> Even.Treasure [n1_s1bc];
          Even.Odd -> Even.Junk [n1_s1bc];
        };
n_r1ab :: GHC.Types.Int = NO_CCS GHC.Types.I#! [3];
Even.main :: Even.TorJ GHC.Types.Int GHC.Types.Int =
    \u srt:SRT:[rlC :-> Even.parity] []
        case Even.parity n_r1ab of _ {
          Even.Even -> Even.Treasure [n_r1ab];
          Even.Odd -> Even.Junk [n_r1ab];
        };
Even.Treasure
  :: forall a_alH b_alI. a_alH -> Even.TorJ a_alH b_alI =
    \r srt:SRT:[] [eta_B1] Even.Treasure [eta_B1];
Even.Junk
  :: forall a_alH b_alI. b_alI -> Even.TorJ a_alH b_alI =
    \r srt:SRT:[] [eta_B1] Even.Junk [eta_B1];
Even.Even :: Even.Parity = NO_CCS Even.Even! [];
Even.Odd :: Even.Parity = NO_CCS Even.Odd! [];


