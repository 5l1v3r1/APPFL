(StgNonRec)
  TestMatch.m5 =
  (FUN) Upd: r
  [ds!4JiBzB]
    (Let) let
      (StgNonRec)
        sat!6JiBzB =
        (THUNK) Upd: u
          (Let) let
            (StgNonRec)
              sat!5JiBzB =
              (CONish) APPFL.Integer.Type.S# [(MachInt) 1]
              Worker/Wrapper: APPFL.Integer.Type.$WS#
          in (App) APPFL.Base.fromInteger sat!5JiBzB
    in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!6JiBzB = wild!7JiBzB
         (AlgAlt)
           (DataAlt) APPFL.Types.False
             -> (Let) let
                  (StgNonRec)
                    sat!9JiBzB =
                    (THUNK) Upd: u
                      (Let) let
                        (StgNonRec)
                          sat!8JiBzB =
                          (CONish) APPFL.Integer.Type.S# [(MachInt) 34]
                          Worker/Wrapper: APPFL.Integer.Type.$WS#
                      in (App) APPFL.Base.fromInteger sat!8JiBzB
                in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!9JiBzB = wild1!-JiBzB
                     (AlgAlt)
                       (DataAlt) APPFL.Types.False
                         -> (Let) let
                              (StgNonRec)
                                sat!AKiBzB =
                                (THUNK) Upd: u
                                  (Let) let
                                    (StgNonRec)
                                      sat!_JiBzB =
                                      (CONish) APPFL.Integer.Type.S# [(MachInt) 18234]
                                      Worker/Wrapper: APPFL.Integer.Type.$WS#
                                  in (App) APPFL.Base.fromInteger sat!_JiBzB
                            in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!AKiBzB = wild2!BKiBzB
                                 (AlgAlt)
                                   (DataAlt) APPFL.Types.False
                                     -> (Let) let
                                          (StgNonRec)
                                            sat!DKiBzB =
                                            (THUNK) Upd: u
                                              (Let) let
                                                (StgNonRec)
                                                  sat!CKiBzB =
                                                  (CONish) APPFL.Integer.Type.S# [(MachInt) 0]
                                                  Worker/Wrapper: APPFL.Integer.Type.$WS#
                                              in (App) APPFL.Base.fromInteger sat!CKiBzB
                                        in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!DKiBzB = wild3!EKiBzB
                                             (AlgAlt)
                                               (DataAlt) APPFL.Types.False
                                                 -> (Let) let
                                                      (StgNonRec)
                                                        sat!HKiBzB =
                                                        (THUNK) Upd: u
                                                          (Let) let
                                                            (StgNonRec)
                                                              sat!GKiBzB =
                                                              (THUNK) Upd: u
                                                                (Let) let
                                                                  (StgNonRec)
                                                                    sat!FKiBzB =
                                                                    (CONish) APPFL.Integer.Type.S# [(MachInt) 3]
                                                                    Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                in (App) APPFL.Base.fromInteger sat!FKiBzB
                                                          in (App) APPFL.Num.negate sat!GKiBzB
                                                    in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!HKiBzB = wild4!IKiBzB
                                                         (AlgAlt)
                                                           (DataAlt) APPFL.Types.False
                                                             -> (Let) let
                                                                  (StgNonRec)
                                                                    sat!KKiBzB =
                                                                    (THUNK) Upd: u
                                                                      (Let) let
                                                                        (StgNonRec)
                                                                          sat!JKiBzB =
                                                                          (CONish) APPFL.Integer.Type.S# [(MachInt) 7]
                                                                          Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                      in (App) APPFL.Base.fromInteger sat!JKiBzB
                                                                in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!KKiBzB = wild5!LKiBzB
                                                                     (AlgAlt)
                                                                       (DataAlt) APPFL.Types.False
                                                                         -> (Let) let
                                                                              (StgNonRec)
                                                                                sat!NKiBzB =
                                                                                (THUNK) Upd: u
                                                                                  (Let) let
                                                                                    (StgNonRec)
                                                                                      sat!MKiBzB =
                                                                                      (CONish) APPFL.Integer.Type.S# [(MachInt) 38832]
                                                                                      Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                                  in (App) APPFL.Base.fromInteger sat!MKiBzB
                                                                            in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!NKiBzB = wild6!OKiBzB
                                                                                 (AlgAlt)
                                                                                   (DataAlt) APPFL.Types.False
                                                                                     -> (Let) let
                                                                                          (StgNonRec)
                                                                                            sat!QKiBzB =
                                                                                            (THUNK) Upd: u
                                                                                              (Let) let
                                                                                                (StgNonRec)
                                                                                                  sat!PKiBzB =
                                                                                                  (CONish) APPFL.Integer.Type.S# [(MachInt) 349]
                                                                                                  Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                                              in (App) APPFL.Base.fromInteger sat!PKiBzB
                                                                                        in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!QKiBzB = wild7!RKiBzB
                                                                                             (AlgAlt)
                                                                                               (DataAlt) APPFL.Types.False
                                                                                                 -> (Let) let
                                                                                                      (StgNonRec)
                                                                                                        sat!TKiBzB =
                                                                                                        (THUNK) Upd: u
                                                                                                          (Let) let
                                                                                                            (StgNonRec)
                                                                                                              sat!SKiBzB =
                                                                                                              (CONish) APPFL.Integer.Type.S# [(MachInt) 6]
                                                                                                              Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                                                          in (App) APPFL.Base.fromInteger sat!SKiBzB
                                                                                                    in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!TKiBzB = wild8!UKiBzB
                                                                                                         (AlgAlt)
                                                                                                           (DataAlt) APPFL.Types.False
                                                                                                             -> (Let) let
                                                                                                                  (StgNonRec)
                                                                                                                    sat!WKiBzB =
                                                                                                                    (THUNK) Upd: u
                                                                                                                      (Let) let
                                                                                                                        (StgNonRec)
                                                                                                                          sat!VKiBzB =
                                                                                                                          (CONish) APPFL.Integer.Type.S# [(MachInt) 444]
                                                                                                                          Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                                                                      in (App) APPFL.Base.fromInteger sat!VKiBzB
                                                                                                                in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!WKiBzB = wild9!XKiBzB
                                                                                                                     (AlgAlt)
                                                                                                                       (DataAlt) APPFL.Types.False
                                                                                                                         -> (Let) let
                                                                                                                              (StgNonRec)
                                                                                                                                sat!ZKiBzB =
                                                                                                                                (THUNK) Upd: u
                                                                                                                                  (Let) let
                                                                                                                                    (StgNonRec)
                                                                                                                                      sat!YKiBzB =
                                                                                                                                      (CONish) APPFL.Integer.Type.S# [(MachInt) 101]
                                                                                                                                      Worker/Wrapper: APPFL.Integer.Type.$WS#
                                                                                                                                  in (App) APPFL.Base.fromInteger sat!YKiBzB
                                                                                                                            in (Case) (App) APPFL.Classes.== ds!4JiBzB sat!ZKiBzB = wild10!aKiBzB
                                                                                                                                 (AlgAlt)
                                                                                                                                   (DataAlt) APPFL.Types.False
                                                                                                                                     -> (App) Control.Exception.Base.patError (MachStr) "../test/haskell/TestMatch.hs:(26,1)-(36,13)|function m5"#
                                                                                                                                   (DataAlt) APPFL.Types.True
                                                                                                                                     -> (ConApp) APPFL.Types.True []
                                                                                                                       (DataAlt) APPFL.Types.True
                                                                                                                         -> (ConApp) APPFL.Types.True []
                                                                                                           (DataAlt) APPFL.Types.True
                                                                                                             -> (ConApp) APPFL.Types.True []
                                                                                               (DataAlt) APPFL.Types.True
                                                                                                 -> (ConApp) APPFL.Types.True []
                                                                                   (DataAlt) APPFL.Types.True
                                                                                     -> (ConApp) APPFL.Types.True []
                                                                       (DataAlt) APPFL.Types.True
                                                                         -> (ConApp) APPFL.Types.True []
                                                           (DataAlt) APPFL.Types.True
                                                             -> (ConApp) APPFL.Types.True []
                                               (DataAlt) APPFL.Types.True
                                                 -> (ConApp) APPFL.Types.True []
                                   (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.True []
                       (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.True []
           (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.True []
(StgNonRec)
  TestMatch.m4 =
  (FUN) Upd: r
  [ds!bKiBzB]
    (Case) (App) ds!bKiBzB = wild!cKiBzB
      (AlgAlt)
        (DEFAULT) _
          -> (Let) let
               (StgNonRec)
                 sat!eKiBzB =
                 (THUNK) Upd: u
                   (Let) let
                     (StgNonRec)
                       sat!dKiBzB =
                       (CONish) APPFL.Integer.Type.S# [(MachInt) 0]
                       Worker/Wrapper: APPFL.Integer.Type.$WS#
                   in (App) APPFL.Base.fromInteger sat!dKiBzB
             in (ConApp) TestMatch.C [sat!eKiBzB]
        (DataAlt) TestMatch.A -> (ConApp) TestMatch.B []
(StgNonRec)
  TestMatch.m3 =
  (FUN) Upd: r
  [ds!fKiBzB]
    (Let) let
      (StgNonRec)
        sat!kKiBzB =
        (THUNK) Upd: u
          (Case) (App) ds!fKiBzB = wild!iKiBzB
            (AlgAlt)
              (DEFAULT) _
                -> (App) Control.Exception.Base.irrefutPatError (MachStr) "../test/haskell/TestMatch.hs:19:1-17|(C i)"#
              (DataAlt) TestMatch.C i!jKiBzB -> (App) i!jKiBzB
    in (Let) let
         (StgNonRec)
           sat!hKiBzB =
           (THUNK) Upd: u
             (Let) let
               (StgNonRec)
                 sat!gKiBzB =
                 (CONish) APPFL.Integer.Type.S# [(MachInt) 5]
                 Worker/Wrapper: APPFL.Integer.Type.$WS#
             in (App) APPFL.Base.fromInteger sat!gKiBzB
       in (App) APPFL.Num.+ sat!hKiBzB sat!kKiBzB
(StgNonRec)
  TestMatch.m2 =
  (FUN) Upd: r
  [t!lKiBzB]
    (Case) (App) t!lKiBzB = wild!mKiBzB
      (AlgAlt)
        (DataAlt) TestMatch.A
          -> (Let) let
               (StgNonRec)
                 sat!nKiBzB =
                 (CONish) APPFL.Integer.Type.S# [(MachInt) 23]
                 Worker/Wrapper: APPFL.Integer.Type.$WS#
             in (App) APPFL.Base.fromInteger sat!nKiBzB
        (DataAlt) TestMatch.B
          -> (App) Control.Exception.Base.patError (MachStr) "../test/haskell/TestMatch.hs:(15,8)-(17,14)|case"#
        (DataAlt) TestMatch.C i!oKiBzB
          -> (Let) let
               (StgNonRec)
                 sat!qKiBzB =
                 (THUNK) Upd: u
                   (Let) let
                     (StgNonRec)
                       sat!pKiBzB =
                       (CONish) APPFL.Integer.Type.S# [(MachInt) 4]
                       Worker/Wrapper: APPFL.Integer.Type.$WS#
                   in (App) APPFL.Base.fromInteger sat!pKiBzB
             in (App) APPFL.Num.+ i!oKiBzB sat!qKiBzB
(StgNonRec)
  TestMatch.m1 =
  (FUN) Upd: r
  [t!rKiBzB]
    (Case) (App) t!rKiBzB = wild!sKiBzB
      (AlgAlt)
        (DataAlt) TestMatch.A -> (ConApp) TestMatch.B []
        (DataAlt) TestMatch.B -> (ConApp) TestMatch.A []
        (DataAlt) TestMatch.C i!tKiBzB
          -> (Let) let
               (StgNonRec)
                 sat!vKiBzB =
                 (THUNK) Upd: u
                   (Let) let
                     (StgNonRec)
                       sat!uKiBzB =
                       (CONish) APPFL.Integer.Type.S# [(MachInt) 10]
                       Worker/Wrapper: APPFL.Integer.Type.$WS#
                   in (App) APPFL.Base.fromInteger sat!uKiBzB
             in (Case) (App) APPFL.Classes.== i!tKiBzB sat!vKiBzB = wild1!wKiBzB
                  (AlgAlt)
                    (DataAlt) APPFL.Types.False
                      -> (Let) let
                           (StgNonRec)
                             sat!yKiBzB =
                             (THUNK) Upd: u
                               (Let) let
                                 (StgNonRec)
                                   sat!xKiBzB =
                                   (CONish) APPFL.Integer.Type.S# [(MachInt) 20]
                                   Worker/Wrapper: APPFL.Integer.Type.$WS#
                               in (App) APPFL.Base.fromInteger sat!xKiBzB
                         in (Case) (App) APPFL.Classes.== i!tKiBzB sat!yKiBzB = wild2!zKiBzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False
                                  -> (App) Control.Exception.Base.patError (MachStr) "../test/haskell/TestMatch.hs:(11,10)-(13,11)|case"#
                                (DataAlt) APPFL.Types.True -> (ConApp) TestMatch.B []
                    (DataAlt) APPFL.Types.True -> (ConApp) TestMatch.A []
(StgNonRec)
  TestMatch.A =
  (CONish) TestMatch.A []
  Worker/Wrapper: TestMatch.A
(StgNonRec)
  TestMatch.B =
  (CONish) TestMatch.B []
  Worker/Wrapper: TestMatch.B
(StgNonRec)
  TestMatch.C =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) TestMatch.C [eta!BAAACB]
(StgNonRec)
  APPFL.Base.quotRemInt =
  (FUN) Upd: r
  [ds!UMiBzB, ds1!VMiBzB]
    (Case) (App) ds!UMiBzB = wild!WMiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!XMiBzB
          -> (Case) (App) ds1!VMiBzB = wild1!YMiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!ZMiBzB
                   -> (Case) (App) APPFL.Prim.quotRemInt# x1!XMiBzB y!ZMiBzB = ds2!aMiBzB
                        (UbxTupAlt2)
                          (DataAlt) APPFL.Prim.(#,#) ipv!bMiBzB ipv1!cMiBzB
                            -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!bMiBzB,
                                                                 ipv1!cMiBzB] = wild2!dMiBzB
                                 (UbxTupAlt2)
                                   (DataAlt) APPFL.Prim.(#,#) q!eMiBzB r!fMiBzB
                                     -> (Let) let
                                          (StgNonRec)
                                            sat!hMiBzB =
                                            (CONish) APPFL.Types.I# [r!fMiBzB]
                                            Worker/Wrapper: APPFL.Types.I#
                                        in (Let) let
                                             (StgNonRec)
                                               sat!gMiBzB =
                                               (CONish) APPFL.Types.I# [q!eMiBzB]
                                               Worker/Wrapper: APPFL.Types.I#
                                           in (ConApp) APPFL.Tuple.(,) [sat!gMiBzB, sat!hMiBzB]
(StgNonRec)
  APPFL.Base.modInt =
  (FUN) Upd: r
  [ds!iMiBzB, ds1!jMiBzB]
    (Case) (App) ds!iMiBzB = wild!kMiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!lMiBzB
          -> (Case) (App) ds1!jMiBzB = wild1!mMiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!nMiBzB
                   -> (Case) (App) APPFL.Classes.modInt# x1!lMiBzB y!nMiBzB = wild2!oMiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!oMiBzB]
(StgNonRec)
  APPFL.Base.divInt =
  (FUN) Upd: r
  [ds!pMiBzB, ds1!qMiBzB]
    (Case) (App) ds!pMiBzB = wild!rMiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!sMiBzB
          -> (Case) (App) ds1!qMiBzB = wild1!tMiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!uMiBzB
                   -> (Case) (App) APPFL.Classes.divInt# x1!sMiBzB y!uMiBzB = wild2!vMiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!vMiBzB]
(StgNonRec)
  APPFL.Base.remInt =
  (FUN) Upd: r
  [eta!wMiBzB, eta1!xMiBzB]
    (Case) (App) eta!wMiBzB = wild!yMiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!zMiBzB
          -> (Case) (App) eta1!xMiBzB = wild1!0MiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!1MiBzB
                   -> (Case) (App) APPFL.Prim.%# x1!zMiBzB y!1MiBzB = wild2!2MiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!2MiBzB]
(StgNonRec)
  APPFL.Base.quotInt =
  (FUN) Upd: r
  [eta!3MiBzB, eta1!4MiBzB]
    (Case) (App) eta!3MiBzB = wild!5MiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!6MiBzB
          -> (Case) (App) eta1!4MiBzB = wild1!7MiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!8MiBzB
                   -> (Case) (App) APPFL.Prim./# x1!6MiBzB y!8MiBzB = wild2!9MiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [wild2!9MiBzB]
(StgNonRec)
  APPFL.Base.otherwise =
  (CONish) APPFL.Types.True []
  Worker/Wrapper: APPFL.Types.True
(StgNonRec)
  APPFL.Base.ifThenElse =
  (FUN) Upd: r
  [b!-MiBzB, t!_MiBzB, e!ANiBzB]
    (Case) (App) b!-MiBzB = wild!BNiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (App) e!ANiBzB
        (DataAlt) APPFL.Types.True -> (App) t!_MiBzB
(StgNonRec)
  APPFL.Base.divModInt# =
  (FUN) Upd: r
  [x#!CNiBzB, y#!DNiBzB]
    (Let) let
      (StgNonRec)
        sat!HNiBzB =
        (THUNK) Upd: u
          (Case) (Op) (Prim) <# [y#!DNiBzB, (MachInt) 0] = sat!GNiBzB
            (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!GNiBzB
    in (Let) let
         (StgNonRec)
           sat!FNiBzB =
           (THUNK) Upd: u
             (Case) (Op) (Prim) ># [x#!CNiBzB, (MachInt) 0] = sat!ENiBzB
               (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!ENiBzB
       in (Case) (App) APPFL.Classes.&& sat!FNiBzB sat!HNiBzB = wild!INiBzB
            (AlgAlt)
              (DataAlt) APPFL.Types.False
                -> (Let) let
                     (StgNonRec)
                       sat!MNiBzB =
                       (THUNK) Upd: u
                         (Case) (Op) (Prim) ># [y#!DNiBzB, (MachInt) 0] = sat!LNiBzB
                           (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!LNiBzB
                   in (Let) let
                        (StgNonRec)
                          sat!KNiBzB =
                          (THUNK) Upd: u
                            (Case) (Op) (Prim) <# [x#!CNiBzB, (MachInt) 0] = sat!JNiBzB
                              (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!JNiBzB
                      in (Case) (App) APPFL.Classes.&& sat!KNiBzB sat!MNiBzB = wild1!NNiBzB
                           (AlgAlt)
                             (DataAlt) APPFL.Types.False
                               -> (App) APPFL.Prim.quotRemInt# x#!CNiBzB y#!DNiBzB
                             (DataAlt) APPFL.Types.True
                               -> (Case) (Op) (Prim) +# [x#!CNiBzB, (MachInt) 1] = sat!ONiBzB
                                    (PrimAlt)
                                      (DEFAULT) _
                                        -> (Case) (App) APPFL.Prim.quotRemInt# sat!ONiBzB y#!DNiBzB = ds!PNiBzB
                                             (UbxTupAlt2)
                                               (DataAlt) APPFL.Prim.(#,#) ipv!QNiBzB ipv1!RNiBzB
                                                 -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!QNiBzB,
                                                                                      ipv1!RNiBzB] = wild2!SNiBzB
                                                      (UbxTupAlt2)
                                                        (DataAlt) APPFL.Prim.(#,#) q!TNiBzB r!UNiBzB
                                                          -> (Case) (Op) (Prim) +# [r!UNiBzB,
                                                                                    y#!DNiBzB] = sat!WNiBzB
                                                               (PrimAlt)
                                                                 (DEFAULT) _
                                                                   -> (Case) (Op) (Prim) -# [sat!WNiBzB,
                                                                                             (MachInt) 1] = sat!XNiBzB
                                                                        (PrimAlt)
                                                                          (DEFAULT) _
                                                                            -> (Case) (Op) (Prim) -# [q!TNiBzB,
                                                                                                      (MachInt) 1] = sat!VNiBzB
                                                                                 (PrimAlt)
                                                                                   (DEFAULT) _
                                                                                     -> (ConApp) APPFL.Prim.(#,#) [sat!VNiBzB,
                                                                                                                   sat!XNiBzB]
              (DataAlt) APPFL.Types.True
                -> (Case) (Op) (Prim) -# [x#!CNiBzB, (MachInt) 1] = sat!YNiBzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Prim.quotRemInt# sat!YNiBzB y#!DNiBzB = ds!ZNiBzB
                              (UbxTupAlt2)
                                (DataAlt) APPFL.Prim.(#,#) ipv!aNiBzB ipv1!bNiBzB
                                  -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!aNiBzB,
                                                                       ipv1!bNiBzB] = wild1!cNiBzB
                                       (UbxTupAlt2)
                                         (DataAlt) APPFL.Prim.(#,#) q!dNiBzB r!eNiBzB
                                           -> (Case) (Op) (Prim) +# [r!eNiBzB,
                                                                     y#!DNiBzB] = sat!gNiBzB
                                                (PrimAlt)
                                                  (DEFAULT) _
                                                    -> (Case) (Op) (Prim) +# [sat!gNiBzB,
                                                                              (MachInt) 1] = sat!hNiBzB
                                                         (PrimAlt)
                                                           (DEFAULT) _
                                                             -> (Case) (Op) (Prim) -# [q!dNiBzB,
                                                                                       (MachInt) 1] = sat!fNiBzB
                                                                  (PrimAlt)
                                                                    (DEFAULT) _
                                                                      -> (ConApp) APPFL.Prim.(#,#) [sat!fNiBzB,
                                                                                                    sat!hNiBzB]
(StgNonRec)
  APPFL.Base.divModInt =
  (FUN) Upd: r
  [ds!iNiBzB, ds1!jNiBzB]
    (Case) (App) ds!iNiBzB = wild!kNiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x1!lNiBzB
          -> (Case) (App) ds1!jNiBzB = wild1!mNiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!nNiBzB
                   -> (Case) (App) APPFL.Base.divModInt# x1!lNiBzB y!nNiBzB = ds2!oNiBzB
                        (UbxTupAlt2)
                          (DataAlt) APPFL.Prim.(#,#) ipv!pNiBzB ipv1!qNiBzB
                            -> (Case) (ConApp) APPFL.Prim.(#,#) [ipv!pNiBzB,
                                                                 ipv1!qNiBzB] = wild2!rNiBzB
                                 (UbxTupAlt2)
                                   (DataAlt) APPFL.Prim.(#,#) q!sNiBzB r!tNiBzB
                                     -> (Let) let
                                          (StgNonRec)
                                            sat!vNiBzB =
                                            (CONish) APPFL.Types.I# [r!tNiBzB]
                                            Worker/Wrapper: APPFL.Types.I#
                                        in (Let) let
                                             (StgNonRec)
                                               sat!uNiBzB =
                                               (CONish) APPFL.Types.I# [q!sNiBzB]
                                               Worker/Wrapper: APPFL.Types.I#
                                           in (ConApp) APPFL.Tuple.(,) [sat!uNiBzB, sat!vNiBzB]
(StgRec)
  x!xFiByB =
  (THUNK) Upd: u (App) x!xFiByB
(StgNonRec)
  APPFL.Base._dummy =
  (THUNK) Upd: u (App) x!xFiByB
(StgNonRec)
  APPFL.Base.fromInteger =
  (THUNK) Upd: u (App) x!xFiByB
(StgNonRec)
  APPFL.Num.mulInt =
  (FUN) Upd: r
  [ds!oPiBzB, ds1!pPiBzB]
    (Case) (App) ds!oPiBzB = wild!qPiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!rPiBzB
          -> (Case) (App) ds1!pPiBzB = wild1!sPiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!tPiBzB
                   -> (Case) (Op) (Prim) *# [a#!rPiBzB, b#!tPiBzB] = sat!uPiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!uPiBzB]
(StgNonRec)
  APPFL.Num.subInt =
  (FUN) Upd: r
  [ds!vPiBzB, ds1!wPiBzB]
    (Case) (App) ds!vPiBzB = wild!xPiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!yPiBzB
          -> (Case) (App) ds1!wPiBzB = wild1!zPiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!0PiBzB
                   -> (Case) (Op) (Prim) -# [a#!yPiBzB, b#!0PiBzB] = sat!1PiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!1PiBzB]
(StgNonRec)
  APPFL.Num.addInt =
  (FUN) Upd: r
  [ds!2PiBzB, ds1!3PiBzB]
    (Case) (App) ds!2PiBzB = wild!4PiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# a#!5PiBzB
          -> (Case) (App) ds1!3PiBzB = wild1!6PiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# b#!7PiBzB
                   -> (Case) (Op) (Prim) +# [a#!5PiBzB, b#!7PiBzB] = sat!8PiBzB
                        (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!8PiBzB]
(StgNonRec)
  APPFL.Num.negate =
  (FUN) Upd: r
  [ds!9PiBzB]
    (Case) (App) ds!9PiBzB = wild!-PiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# i#!_PiBzB
          -> (Case) (Op) (Prim) negateInt# [i#!_PiBzB] = sat!AQiBzB
               (PrimAlt) (DEFAULT) _ -> (ConApp) APPFL.Types.I# [sat!AQiBzB]
(StgNonRec)
  APPFL.Num.% =
  (THUNK) Upd: u (App) APPFL.Base.remInt
(StgNonRec)
  APPFL.Num.mod =
  (THUNK) Upd: u (App) APPFL.Base.remInt
(StgNonRec)
  APPFL.Num.* =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.mulInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Num./ =
  (THUNK) Upd: u (App) APPFL.Base.quotInt
(StgNonRec)
  APPFL.Num.div =
  (THUNK) Upd: u (App) APPFL.Base.quotInt
(StgNonRec)
  APPFL.Num.- =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.subInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Num.+ =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Num.addInt eta!CAAACB eta!BAAACB
(StgNonRec)
  APPFL.Types.isTrue# =
  (FUN) Upd: r
  [ds!vQiBzB]
    (Case) (App) ds!vQiBzB = ds1!wQiBzB
      (PrimAlt)
        (DEFAULT) _ -> (ConApp) APPFL.Types.False []
        (LitAlt) (MachInt) 1 -> (ConApp) APPFL.Types.True []
(StgNonRec)
  APPFL.Types.MkCoercible =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) APPFL.Types.MkCoercible [APPFL.Prim.coercionToken#]
(StgNonRec)
  APPFL.Types.Cons =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (ConApp) APPFL.Types.Cons [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Types.Nil =
  (CONish) APPFL.Types.Nil []
  Worker/Wrapper: APPFL.Types.Nil
(StgNonRec)
  APPFL.Types.Unit =
  (CONish) APPFL.Types.Unit []
  Worker/Wrapper: APPFL.Types.Unit
(StgNonRec)
  APPFL.Types.I# =
  (FUN) Upd: r
  [eta!BAAACB]
    (ConApp) APPFL.Types.I# [eta!BAAACB]
(StgNonRec)
  APPFL.Types.False =
  (CONish) APPFL.Types.False []
  Worker/Wrapper: APPFL.Types.False
(StgNonRec)
  APPFL.Types.True =
  (CONish) APPFL.Types.True []
  Worker/Wrapper: APPFL.Types.True
(StgRec)
  APPFL.Prim.imin# =
  (THUNK) Upd: u (App) x!_QiByB
  x!_QiByB =
  (THUNK) Upd: u (App) APPFL.Prim.imin#
(StgRec)
  APPFL.Prim.imax# =
  (THUNK) Upd: u (App) x1!ARiByB
  x1!ARiByB =
  (THUNK) Upd: u (App) APPFL.Prim.imax#
(StgNonRec)
  APPFL.Prim.ineg# =
  (FUN) Upd: r
  [eta!BAAACB]
    (Op) (Prim) negateInt# [eta!BAAACB]
(StgNonRec)
  APPFL.Prim./# =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (Op) (Prim) quotInt# [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Prim.%# =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (Op) (Prim) remInt# [eta!CAAACB, eta!BAAACB]
(StgNonRec)
  APPFL.Prim.quotRemInt# =
  (FUN) Upd: r
  [a!BRiBzB, b!CRiBzB]
    (Case) (Op) (Prim) quotInt# [a!BRiBzB, b!CRiBzB] = q!DRiBzB
      (PrimAlt)
        (DEFAULT) _
          -> (Case) (Op) (Prim) remInt# [a!BRiBzB, b!CRiBzB] = r!ERiBzB
               (PrimAlt)
                 (DEFAULT) _ -> (ConApp) APPFL.Prim.(#,#) [q!DRiBzB, r!ERiBzB]
(StgNonRec)
  APPFL.Classes.not =
  (FUN) Upd: r
  [ds!ZRiBzB]
    (Case) (App) ds!ZRiBzB = wild!aRiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (ConApp) APPFL.Types.True []
        (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.False []
(StgNonRec)
  APPFL.Classes.|| =
  (FUN) Upd: r
  [ds!bRiBzB, ds1!cRiBzB]
    (Case) (App) ds!bRiBzB = wild!dRiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (App) ds1!cRiBzB
        (DataAlt) APPFL.Types.True -> (ConApp) APPFL.Types.True []
(StgNonRec)
  APPFL.Classes.&& =
  (FUN) Upd: r
  [ds!eRiBzB, x!fRiBzB]
    (Case) (App) ds!eRiBzB = wild!gRiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.False -> (ConApp) APPFL.Types.False []
        (DataAlt) APPFL.Types.True -> (App) x!fRiBzB
(StgNonRec)
  APPFL.Classes.divInt# =
  (FUN) Upd: r
  [x#!hRiBzB, y#!iRiBzB]
    (LetNE) let
      (StgNonRec)
        $j!jRiBzB =
        (FUN) Upd: r
        [w!kRiBzB]
          (Case) (Op) (Prim) <# [x#!hRiBzB, (MachInt) 0] = sat!lRiBzB
            (PrimAlt)
              (DEFAULT) _
                -> (Case) (App) APPFL.Types.isTrue# sat!lRiBzB = wild!mRiBzB
                     (AlgAlt)
                       (DataAlt) APPFL.Types.False
                         -> (Op) (Prim) quotInt# [x#!hRiBzB, y#!iRiBzB]
                       (DataAlt) APPFL.Types.True
                         -> (Case) (Op) (Prim) ># [y#!iRiBzB, (MachInt) 0] = sat!nRiBzB
                              (PrimAlt)
                                (DEFAULT) _
                                  -> (Case) (App) APPFL.Types.isTrue# sat!nRiBzB = wild1!oRiBzB
                                       (AlgAlt)
                                         (DataAlt) APPFL.Types.False
                                           -> (Op) (Prim) quotInt# [x#!hRiBzB, y#!iRiBzB]
                                         (DataAlt) APPFL.Types.True
                                           -> (Case) (Op) (Prim) +# [x#!hRiBzB,
                                                                     (MachInt) 1] = sat!pRiBzB
                                                (PrimAlt)
                                                  (DEFAULT) _
                                                    -> (Case) (Op) (Prim) quotInt# [sat!pRiBzB,
                                                                                    y#!iRiBzB] = wild2!qRiBzB
                                                         (PrimAlt)
                                                           (DEFAULT) _
                                                             -> (Op) (Prim) -# [wild2!qRiBzB,
                                                                                (MachInt) 1]
    in (Case) (Op) (Prim) ># [x#!hRiBzB, (MachInt) 0] = sat!rRiBzB
         (PrimAlt)
           (DEFAULT) _
             -> (Case) (App) APPFL.Types.isTrue# sat!rRiBzB = wild!sRiBzB
                  (AlgAlt)
                    (DataAlt) APPFL.Types.False -> (App) $j!jRiBzB APPFL.Prim.void#
                    (DataAlt) APPFL.Types.True
                      -> (Case) (Op) (Prim) <# [y#!iRiBzB, (MachInt) 0] = sat!tRiBzB
                           (PrimAlt)
                             (DEFAULT) _
                               -> (Case) (App) APPFL.Types.isTrue# sat!tRiBzB = wild1!uRiBzB
                                    (AlgAlt)
                                      (DataAlt) APPFL.Types.False
                                        -> (App) $j!jRiBzB APPFL.Prim.void#
                                      (DataAlt) APPFL.Types.True
                                        -> (Case) (Op) (Prim) -# [x#!hRiBzB,
                                                                  (MachInt) 1] = sat!vRiBzB
                                             (PrimAlt)
                                               (DEFAULT) _
                                                 -> (Case) (Op) (Prim) quotInt# [sat!vRiBzB,
                                                                                 y#!iRiBzB] = wild2!wRiBzB
                                                      (PrimAlt)
                                                        (DEFAULT) _
                                                          -> (Op) (Prim) -# [wild2!wRiBzB,
                                                                             (MachInt) 1]
(StgNonRec)
  APPFL.Classes.modInt# =
  (FUN) Upd: r
  [x#!xRiBzB, y#!yRiBzB]
    (Case) (Op) (Prim) remInt# [x#!xRiBzB, y#!yRiBzB] = r#!zRiBzB
      (PrimAlt)
        (DEFAULT) _
          -> (LetNE) let
               (StgNonRec)
                 $j!0RiBzB =
                 (FUN) Upd: r
                 [w!1RiBzB]
                   (Case) (App) r#!zRiBzB = wild!2RiBzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Types.isTrue# (MachInt) 1 = wild1!3RiBzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (Lit) (MachInt) 0
                                (DataAlt) APPFL.Types.True
                                  -> (Op) (Prim) +# [wild!2RiBzB, y#!yRiBzB]
                       (LitAlt) (MachInt) 0
                         -> (Case) (App) APPFL.Types.isTrue# (MachInt) 0 = wild1!4RiBzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (Lit) (MachInt) 0
                                (DataAlt) APPFL.Types.True -> (App) y#!yRiBzB
             in (LetNE) let
                  (StgNonRec)
                    $j1!5RiBzB =
                    (FUN) Upd: r
                    [w!6RiBzB]
                      (Case) (Op) (Prim) <# [x#!xRiBzB, (MachInt) 0] = sat!7RiBzB
                        (PrimAlt)
                          (DEFAULT) _
                            -> (Case) (App) APPFL.Types.isTrue# sat!7RiBzB = wild!8RiBzB
                                 (AlgAlt)
                                   (DataAlt) APPFL.Types.False -> (App) r#!zRiBzB
                                   (DataAlt) APPFL.Types.True
                                     -> (Case) (Op) (Prim) ># [y#!yRiBzB, (MachInt) 0] = sat!9RiBzB
                                          (PrimAlt)
                                            (DEFAULT) _
                                              -> (Case) (App) APPFL.Types.isTrue# sat!9RiBzB = wild1!-RiBzB
                                                   (AlgAlt)
                                                     (DataAlt) APPFL.Types.False -> (App) r#!zRiBzB
                                                     (DataAlt) APPFL.Types.True
                                                       -> (App) $j!0RiBzB APPFL.Prim.void#
                in (Case) (Op) (Prim) ># [x#!xRiBzB, (MachInt) 0] = sat!_RiBzB
                     (PrimAlt)
                       (DEFAULT) _
                         -> (Case) (App) APPFL.Types.isTrue# sat!_RiBzB = wild!ASiBzB
                              (AlgAlt)
                                (DataAlt) APPFL.Types.False -> (App) $j1!5RiBzB APPFL.Prim.void#
                                (DataAlt) APPFL.Types.True
                                  -> (Case) (Op) (Prim) <# [y#!yRiBzB, (MachInt) 0] = sat!BSiBzB
                                       (PrimAlt)
                                         (DEFAULT) _
                                           -> (Case) (App) APPFL.Types.isTrue# sat!BSiBzB = wild1!CSiBzB
                                                (AlgAlt)
                                                  (DataAlt) APPFL.Types.False
                                                    -> (App) $j1!5RiBzB APPFL.Prim.void#
                                                  (DataAlt) APPFL.Types.True
                                                    -> (App) $j!0RiBzB APPFL.Prim.void#
(StgNonRec)
  APPFL.Classes.leInt =
  (FUN) Upd: r
  [eta!DSiBzB, eta1!ESiBzB]
    (Case) (App) eta!DSiBzB = wild!FSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!GSiBzB
          -> (Case) (App) eta1!ESiBzB = wild1!HSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!ISiBzB
                   -> (Case) (Op) (Prim) <=# [x!GSiBzB, y!ISiBzB] = sat!JSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!JSiBzB
(StgNonRec)
  APPFL.Classes.ltInt =
  (FUN) Upd: r
  [eta!KSiBzB, eta1!LSiBzB]
    (Case) (App) eta!KSiBzB = wild!MSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!NSiBzB
          -> (Case) (App) eta1!LSiBzB = wild1!OSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!PSiBzB
                   -> (Case) (Op) (Prim) <# [x!NSiBzB, y!PSiBzB] = sat!QSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!QSiBzB
(StgNonRec)
  APPFL.Classes.geInt =
  (FUN) Upd: r
  [eta!RSiBzB, eta1!SSiBzB]
    (Case) (App) eta!RSiBzB = wild!TSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!USiBzB
          -> (Case) (App) eta1!SSiBzB = wild1!VSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!WSiBzB
                   -> (Case) (Op) (Prim) >=# [x!USiBzB, y!WSiBzB] = sat!XSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!XSiBzB
(StgNonRec)
  APPFL.Classes.gtInt =
  (FUN) Upd: r
  [eta!YSiBzB, eta1!ZSiBzB]
    (Case) (App) eta!YSiBzB = wild!aSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!bSiBzB
          -> (Case) (App) eta1!ZSiBzB = wild1!cSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!dSiBzB
                   -> (Case) (Op) (Prim) ># [x!bSiBzB, y!dSiBzB] = sat!eSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!eSiBzB
(StgNonRec)
  APPFL.Classes.neInt =
  (FUN) Upd: r
  [eta!fSiBzB, eta1!gSiBzB]
    (Case) (App) eta!fSiBzB = wild!hSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!iSiBzB
          -> (Case) (App) eta1!gSiBzB = wild1!jSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!kSiBzB
                   -> (Case) (Op) (Prim) /=# [x!iSiBzB, y!kSiBzB] = sat!lSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!lSiBzB
(StgNonRec)
  APPFL.Classes.eqInt =
  (FUN) Upd: r
  [eta!mSiBzB, eta1!nSiBzB]
    (Case) (App) eta!mSiBzB = wild!oSiBzB
      (AlgAlt)
        (DataAlt) APPFL.Types.I# x!pSiBzB
          -> (Case) (App) eta1!nSiBzB = wild1!qSiBzB
               (AlgAlt)
                 (DataAlt) APPFL.Types.I# y!rSiBzB
                   -> (Case) (Op) (Prim) ==# [x!pSiBzB, y!rSiBzB] = sat!sSiBzB
                        (PrimAlt) (DEFAULT) _ -> (App) APPFL.Types.isTrue# sat!sSiBzB
(StgNonRec)
  APPFL.Classes.== =
  (FUN) Upd: r
  [eta!CAAACB, eta!BAAACB]
    (App) APPFL.Classes.eqInt eta!CAAACB eta!BAAACB