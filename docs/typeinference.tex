\documentclass[11pt]{article}

% preamble

\newcommand{\bu}{\vdash_\mathrm{BU}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cC}{\mathcal{C}}
\usepackage{bussproofs}
\usepackage{geometry}
\geometry{
  letterpaper,
  lmargin=1in,
  rmargin=1in,
  tmargin=1in,
  bmargin=1in
}
\usepackage{amssymb}
\let\oldemptyset\emptyset
\let\emptyset\varnothing

\begin{document}

% top matter

\title{Bottom-up Hindley-Milner Type Inference Rules for Realistic Functional Languages}
\author{Kei Davis}
\date{January 2015}
\maketitle

% \renewcommand{\abstractname}{Executive Summary}
\begin{abstract}
  The great majority of papers on Hindley-Milner type inference provide rules
  for only the simplest of type systems, for example lacking sum types, and
  the simplest of language constructs, for example lacking recursive
  definitions and sum deconstruction, leaving type inference for more
  realistic languages as ``straightforward'' generalizations or extensions.
  Anecdotal evidence suggests that practitioners in fact find generalization
  or extension less than straightforward.  Indeed, prior to Heeren et al.'s
  landmark work~\cite{HHS02}, obtaining a sound ordering in the various steps
  (specialization, generalization, etc.) was arguably a black art.  Using the
  approach of Heeren et al.\ we give type inference rules for two languages:
  one modeled after GHC's STG intermediate language~\cite{PJ??}, the other a
  simple, generic, higher-order polymorphic functional language designed to
  facilitate the explication and implementation of a strictness analysis
  technique.  Both use a common sub-language for defining algebraic data types
  including user-defined \emph{unboxed types}, the latter for which typing
  rules are given as suggested by Peyton Jones and Launchbury~\cite{PJL??}.
\end{abstract}

% main body

\section{Introduction}
We follow the approach of Heeren et al.~\cite{HHS02}.

\section{Language---Heeren, Hage, Swierstra}

\section{Language---Datatype Declarations}

\setlength{\tabcolsep}{5pt}
\begin{figure}
\centering
\footnotesize % tiny scriptsize footnotesize small
\begin{tabular}{r r c l l}
  Type constr.\ defn. &  $\mathit{tdef}$ & ::= & \texttt{data} [\texttt{unboxed}]\ 
  $T\ \beta_1 \dots \beta_m\ \mbox{\texttt{=}} $ & $m \ge 0,\ n \ge 1$\\
  & & & \quad $C_1\ \tau_{1,1} \dots \tau_{1,a_1}\ \mbox{\texttt{|}}\ \dots\ \mbox{\texttt{|}}\ C_n\ t_{1,1} \dots t_{1,a_n}  $ \\
\\
Type               & $\tau$           & ::= & \emph{Primtype}           & Primitive type\\
                   &                  & $|$ & $\beta$                   & Type variable \\
                   &                  & $|$ & $\tau$ \texttt{->} $\tau$ & Function type \\
                   &                  & $|$ & $T\ \tau\ \dots\ \tau$    & Type constructor\\
\end{tabular}
\caption{Type Declaration Syntax}
\label{fig:typedecsyntax}
\end{figure}

\section{Language---STG}

\setlength{\tabcolsep}{5pt}
\begin{figure}
\centering
\footnotesize % tiny scriptsize footnotesize small
\begin{tabular}{r r c l l}
Variable     & $f,\ x$        &     &                                              & Initial lower-case letter \\
\\
Constructor  & $C$            &     &                                              & Initial upper-case letter \\
\\
Atom         & $a$            & ::= & $i\ |\ x$                                    & Variable or integer literal\\
\\
Expression   & $e$            & ::= & $a$                                          & Atom \\
             &                & $|$ & $f\ a_1\dots a_n$                            & Application, $n\ge 1$ \\
             &                & $|$ & $\oplus\ a_1\dots a_n$                       & Saturated primitive operation, $n\ge 1$ \\

             &                & $|$ & \texttt{let}                                 & Recursive let, $n\ge 1$ \\
             &                &     & \texttt{ } $\mathit{odecl}_1$ \\
             &                &     & \hspace{0.2in} $\dots$ \\
             &                &     & \texttt{ } $\mathit{odecl}_n$ \\
%             &                &     & \texttt{ } $x_1$ \texttt{=} $\mathit{obj}_1$ \\
%             &                &     & \hspace{0.2in} $\dots$ \\
%             &                &     & \texttt{ } $x_n$ \texttt{=} $\mathit{obj}_n$ \\
             &                &     & \texttt{in} $e$  \\
\\
             &                & $|$ & \texttt{case} $e$ \texttt{of} $\mathit{alts}$ & Case expression (former) \\
\\
             &                & $|$ & \texttt{case} $e$ \texttt{as} $x$ \texttt{of} $\mathit{alts}$ & Case expression (current) \\
\\
Alternatives & $\mathit{alts}$ & ::= & \texttt{ } $\mathit{alt}_1$                  & Case alternatives, $n \ge 1$\\
             &                &     & \hspace{0.2in} $\dots$ \\
             &                &     & \texttt{ } $\mathit{alt}_n$ \\
\\
Alternative  & $\mathit{alt}$ & ::= & $C\ x_1\dots x_n$ \texttt{->} $e$            & Pattern match, $n \ge 0$ \\
             &                & $|$ & $i$                                          & Integer literal \\
             &                & $|$ & \texttt{\_ ->} $e$                           & Default \\
\\
Object       & $\mathit{obj}$ & ::= &\texttt{FUN} $f\ x_1\dots x_n$ \texttt{->} $e$   & Function definition, arity $=n\ge 1$ \\
             &                & $|$ &\texttt{CON} $C\ a_1\dots a_n$                & Saturated constructor, $n \ge 0$ \\
             &                & $|$ &\texttt{THUNK} $e$                            & Thunk---explicit deferred evaluation \\
%             &                & $|$ &\texttt{PAP} $f\ a_1\dots a_n$               & Partial application \\
%             &                & $|$ & $\mathit{BLACKHOLE}$                         & Evaluation-time black hole \\
\\
Object decl. & $\mathit{odecl}$ & ::=  & $x = \mathit{obj}$                           & Simple binding \\
\\
%%%Constructor defn. & $\mathit{con}$  & ::= & $C\ \mathit{type}_i$ & $i \ge 0$ \\
%%%\\
%%%Datatype defn. &  $\mathit{ddecl}$ & ::= & \texttt{data} [\texttt{unboxed}] & User-defined data type  \\
%%%               &                   &     & $C\ x_i =$                       & $i \ge 0, n > 0$         \\
%%%               &                   &     & $\mathit{con}_1 | \dots |  \mathit{con}_n$ \\
%%%\\
%%%Program      & $\mathit{prog}$ & ::= & $\mathit{(o|d)decl}_1$ \texttt{;}            & Object and data defns, \\
%%%             &                 &     & \texttt{ } $\dots$ \texttt{;}                & distinguished \texttt{main}\\
%%%             &                 &     & $\mathit{(o|d)decl}_n$ & 
Program      & $\mathit{prog}$ & ::= & $\mathit{odecl}_1$ \texttt{;}            & Object and data defns, \\
             &                 &     & \texttt{ } $\dots$ \texttt{;}                & distinguished \texttt{main}\\
             &                 &     & $\mathit{odecl}_n$ & 
%Program      & $\mathit{prog}$& ::= & $f_1\ =\ \mathit{obj}_1$ \texttt{;}          & $n \ge 1$, distinguished \texttt{main}\\
%             &                &     & \texttt{ } $\dots$ \texttt{;} \\
%             &                &     & $f_n\ =\ \mathit{obj}_n$

\end{tabular}
\caption{STG syntax}
\label{fig:STGsyntax}
\end{figure}

\clearpage
\section{Type inference rules}
Judgements are of the form $\cA,\ \cC\ \bu\ e:\tau$.   Subscript indexes
are implicit except where needed for clarity.\\

Starting with the base cases, each leaf (Expression/Atom) variable is
associated with a fresh type variable, and each literal is associated with its
(unambiguous) type, e.g., $i:\mathit{Int}$ or $i:\mathit{Int\#}$, and
Primitive operators are assumed to be monomorphic.
For recursive \texttt{let} it is convenient to separate the \texttt{let} and \texttt{in} clauses.
Built-in functions are assumed to have to

\begin{figure}
% Variable/Atom
%
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{[Variable/Atom]}
  \UnaryInfC{$\{x:\beta\},\ \emptyset\ \vdash\ x:\beta\ (\beta\ \mathrm{fresh})$}
\end{prooftree}
%
% Literal/Atom
%
\begin{prooftree}
  \AxiomC{}
  \LeftLabel{[Literal/Atom]\quad}
  \UnaryInfC{$\emptyset,\ \emptyset\ \vdash\ i:\mathrm{Int}$}
\end{prooftree}
%
% Expression/Application
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ (=\emptyset)\ \vdash\ a_i:\tau_i$}
  \LeftLabel{[Expression/Application]\quad}
  \UnaryInfC{$\bigcup \cA_i \cup \{f:\tau_1 \rightarrow \ldots \rightarrow \tau_n \rightarrow \beta \}
      \ \vdash f\ a_1 \ldots a_n : \beta\ (\beta\ \mathrm{fresh})$ }
\end{prooftree}
%
% Primitive Operation
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ \vdash\ a_i:\tau_i$}
  \AxiomC{$\oplus : \tau_1 \rightarrow \ldots \rightarrow \tau_n \rightarrow \tau_{n+1}$}
  \LeftLabel{[Primitive Operation]\quad}
  \BinaryInfC{$\bigcup \cA_i,\ \{ \tau_i \equiv \tau_i \}\ \vdash\ \oplus\ a_1 \ldots a_n : \tau_{n+1}$}
\end{prooftree}
%
% let
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ \vdash\ e_i:\tau_i,\ 1\le i \le n$}
  \LeftLabel{[\texttt{let}]\quad}
  \UnaryInfC{$(\bigcup \cA_i)\backslash \{x_i\},\ \bigcup \cC_i \cup \{\tau' \equiv \tau_i\ |\ x_i : \tau' \in \cA_j,\
    1 \le i \le n,\ 1 \le j \le n \}\ \vdash\ \mbox{\texttt{let}}\ x_i = e_i : \tau_i$}
\end{prooftree}
%
% in
%
\begin{prooftree}
  \AxiomC{$\cA,\ \cC\ \vdash\ \mbox{\texttt{let}}\ x_i = e_i : \tau_i$}
  \AxiomC{$\cA_0,\ \cC_0\ \vdash\ e_0:\tau_0$}
  \LeftLabel{[\texttt{in}]\quad}
  \BinaryInfC{$\cA \cup (\cA_0 \backslash \{x_i\}),\ \cC \cup \cC_0 \cup
    \{ \tau' \le_{M} \tau_i\ |\ x_i:\tau' \in \cA_0 \}
    \ \vdash\ \mbox{\texttt{let}}\ x_i = e_i\ \mbox{\texttt{in}}\ e_0:\tau_0$}
\end{prooftree}
%
% case
%
\begin{prooftree}
  \AxiomC{$\cA_0,\ \cC_0\ \vdash\ e_0 : \tau_0$}
  \AxiomC{$\cA_\mathit{alts},\ \cC_\mathit{alts}\ \vdash_{\tau_0}\ \mathit{alts} : \tau_\mathit{alts}$}
  \LeftLabel{[\texttt{case}]\quad}
  \BinaryInfC{$\cA_0 \cup \cA_\mathit{alts},\ 
    \cC_0 \cup \cC_\mathit{alts} \vdash\
    \mbox{\texttt{case}}\ e_0\ \mbox{\texttt{of}}\ \mathit{alts}:\tau_\mathit{alts}$}
\end{prooftree}
%
% alts
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ \vdash_{\tau_0}\ \mathit{alt}_i : \tau_i$}
  \LeftLabel{[\texttt{alts}]\quad}
  \UnaryInfC{$\bigcup \cA_i,\  \bigcup \cC_i \cup \{ \tau_1 \equiv \tau'\ |\ 2 \le i \le n \}\ \vdash_{\tau_0}\
    \mathit{alts} : \tau_1 $}
\end{prooftree}
%
% FUN
%
\begin{prooftree}
  \AxiomC{$\cA,\ \cC\ \vdash\ e : \tau$}
  \LeftLabel{[FUN]\quad}
  \UnaryInfC{$\cA \backslash \{x_i\} \cup \{f : \beta_1 \rightarrow \dots \rightarrow \beta_n \rightarrow \tau\} \ (\beta_i\ \mathrm{fresh}),$}
  \noLine
  \UnaryInfC{$\cC \cup \{\tau' \equiv \beta_i\ |\ x_i : \tau' \in \cA,\ 1\le i \le n\}$}
  \noLine
  \UnaryInfC{$\vdash\ \mbox{\texttt{FUN}}\ f\ x_1 \dots x_n\ \mbox{\texttt{->}}\ e : \beta_1 \rightarrow \dots \rightarrow \beta_n \rightarrow \tau$}
\end{prooftree}
%
% CON
%
\begin{prooftree}
  \AxiomC{$\cA,\ \cC\ \vdash\ a_i : \tau_i$}
  \AxiomC{$T\ \beta_1 \dots \beta_j \rightarrow C\ m_1 \dots m_n\ (\beta_i\ \mbox{fresh})$}
  \LeftLabel{[CON]\quad}
  \BinaryInfC{$\cA,\ \cC\ \vdash\ \mbox{\texttt{THUNK}}\ e : \tau$}
\end{prooftree}
%
% THUNK
%
\begin{prooftree}
  \AxiomC{$\cA,\ \cC\ \vdash\ e : \tau$}
  \LeftLabel{[THUNK]\quad}
  \UnaryInfC{$\cA,\ \cC\ \vdash\ \mbox{\texttt{THUNK}}\ e : \tau$}
\end{prooftree}
\caption{STG Bottom-up Type Inference Rules (as implemented)}
\label{fig:BUSTG}
\end{figure}

\begin{figure}
%
% case
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ \vdash\ \mathit{alt}_i:\tau_0$}
  \LeftLabel{[\texttt{case}]\quad}
  \UnaryInfC{$\cA_0 \cup (\cA_\mathit{alts}\backslash\{x_0\}),\ 
    \cC_0 \cup \cC_\mathit{alts} \cup \{\tau_0 \equiv \tau'\ |\ x:\tau' \in \cA_\mathit{alts} \}\ \vdash\
    \mbox{\texttt{case}}\ e_0\ \mbox{\texttt{as}}\ x_0\ \mbox{\texttt{of}}\ \mathit{alts}:\tau_\mathit{alts}$}
\end{prooftree}
%
% alts
%
\begin{prooftree}
  \AxiomC{$\cA_i,\ \cC_i\ \vdash\ \mathit{alt}_i : \tau_i$}
  \LeftLabel{[\texttt{alts}]\quad}
  \UnaryInfC{$\bigcup \cA_i,\  \bigcup \cC_i \cup \{ \tau_1 \equiv \tau_i\ |\ 2 \le i \le n \}\ \vdash\
    \mathit{alts} : \tau_1 $}
\end{prooftree}
\caption{STG Proposed Inference Rules for \texttt{case}}
\label{fig:proposed}
\end{figure}


\section{Language---Analysis Target}
Minimalistic Higher-order, Polymorphic, Pure Functional Language
  
\end{document}

Using the command \EnableBpAbbreviations enables some laconic shorthand for various commands:
\AX and \AXC abbreviate \Axiom and \AxiomC
\UI and \UIC abbreviate \UnaryInf and \UnaryInfC
\BI and \BIC abbreviate \BinaryInf and \BinaryInfC
\TI and \TIC abbreviate \TrinaryInf and \TrinaryInfC
\DP abbreviates \DisplayProof
